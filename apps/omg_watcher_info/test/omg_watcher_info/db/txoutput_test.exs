# Copyright 2019-2020 OmiseGO Pte Ltd
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

defmodule OMG.WatcherInfo.DB.TxOutputTest do
  use ExUnitFixtures
  use ExUnit.Case, async: false
  use OMG.Fixtures

  import Ecto.Query

  import OMG.WatcherInfo.Factory

  alias OMG.Utxo
  alias OMG.WatcherInfo.DB

  require Utxo

  @eth OMG.Eth.RootChain.eth_pseudo_address()

  @tag fixtures: [:phoenix_ecto_sandbox, :alice]
  test "transaction output schema handles big numbers properly", %{alice: alice} do
    power_of_2 = fn n -> :lists.duplicate(n, 2) |> Enum.reduce(&(&1 * &2)) end
    assert 16 == power_of_2.(4)

    big_amount = power_of_2.(256) - 1

    DB.Block.insert_with_transactions(%{
      transactions: [OMG.TestHelper.create_recovered([], @eth, [{alice, big_amount}])],
      blknum: 11_000,
      blkhash: <<?#::256>>,
      timestamp: :os.system_time(:second),
      eth_height: 10
    })

    utxo = DB.TxOutput.get_by_position(Utxo.position(11_000, 0, 0))
    assert not is_nil(utxo)
    assert utxo.amount == big_amount
  end

  describe "OMG.WatcherInfo.DB.TxOutput.spend_utxos/3" do
    # a special test for spend_utxos/3 is here because under the hood it calls update_all/3. using
    # update_all/3 with a queryable means that certain autogenerated columns, such as inserted_at and
    # updated_at, will not be updated as they would be if you used a plain update. More info
    # is here: https://hexdocs.pm/ecto/Ecto.Repo.html#c:update_all/3
    @tag fixtures: [:phoenix_ecto_sandbox]
    test "spend_utxos updates the updated_at timestamp correctly" do
      txoutput = insert(:txoutput)

      utxo_inputs = [{Utxo.position(txoutput.blknum, txoutput.txindex, txoutput.oindex), nil, nil}]

      DB.TxOutput.spend_utxos(utxo_inputs)

      updated_txoutput = DB.TxOutput.get_by_position(Utxo.position(txoutput.blknum, txoutput.txindex, txoutput.oindex))

      assert DateTime.compare(txoutput.inserted_at, updated_txoutput.inserted_at) == :eq

      assert DateTime.compare(updated_txoutput.inserted_at, updated_txoutput.updated_at) == :lt
    end
  end

  describe "OMG.WatcherInfo.DB.TxOutput.get_utxo_by_position/1" do
    @tag fixtures: [:phoenix_ecto_sandbox]
    test "returns a txoutput for the position if the txoutput exists and has not been spent" do
      txoutput =
        build(:txoutput)
        |> with_deposit()
        |> insert()

      utxo = DB.TxOutput.get_utxo_by_position(Utxo.position(txoutput.blknum, txoutput.txindex, txoutput.oindex))

      assert utxo != nil
      assert txoutput.blknum == utxo.blknum
      assert txoutput.txindex == utxo.txindex
      assert txoutput.oindex == utxo.oindex
    end

    @tag fixtures: [:phoenix_ecto_sandbox]
    test "returns nil for the position if the txoutput exists, but has been spent" do
      txoutput =
        build(:txoutput)
        |> with_deposit()
        |> with_spending_transaction()
        |> insert()

      assert DB.TxOutput.get_utxo_by_position(Utxo.position(txoutput.blknum, txoutput.txindex, txoutput.oindex)) == nil
    end

    @tag fixtures: [:phoenix_ecto_sandbox]
    test "returns nil for the position if the txoutput exists, but has been exited" do
      txoutput =
        build(:txoutput)
        |> with_deposit()
        |> with_standard_exit()
        |> insert()

      assert DB.TxOutput.get_utxo_by_position(Utxo.position(txoutput.blknum, txoutput.txindex, txoutput.oindex)) == nil
    end

    @tag fixtures: [:phoenix_ecto_sandbox]
    test "returns nil for the position if the txoutput does not exist" do
      assert DB.TxOutput.get_utxo_by_position(Utxo.position(0, 0, 0)) == nil
    end
  end

  describe "OMG.WatcherInfo.DB.TxOutput.get_utxos/1" do
    @tag fixtures: [:phoenix_ecto_sandbox]
    test "returns a txoutputs for the owner address if the txoutputs exist and have not been spent" do
      txoutput =
        build(:txoutput)
        |> with_deposit()
        |> insert()

      utxos = DB.TxOutput.get_utxos(txoutput.owner)

      assert utxos != nil
      assert length(utxos) == 1

      [utxo | _] = utxos

      assert txoutput.blknum == utxo.blknum
      assert txoutput.txindex == utxo.txindex
      assert txoutput.oindex == utxo.oindex
    end

    @tag fixtures: [:phoenix_ecto_sandbox]
    test "returns empty array for the owner address if the txoutputs exist, but have been spent" do
      txoutput =
        build(:txoutput)
        |> with_deposit()
        |> with_spending_transaction()
        |> IO.inspect(label: "txoutput")
        |> insert()

      assert length(DB.TxOutput.get_utxos(txoutput.owner)) == 0
    end

    @tag fixtures: [:phoenix_ecto_sandbox]
    test "returns empty array for the owner address if the txoutputs exist, but have been exited" do
      txoutput =
        build(:txoutput)
        |> with_deposit()
        |> with_standard_exit()
        |> insert()

      assert length(DB.TxOutput.get_utxos(txoutput.owner)) == 0
    end

    @tag fixtures: [:phoenix_ecto_sandbox]
    test "returns a filtered list of txoutputs for the owner address that have not been spent nor exited" do
      txoutput =
        build(:txoutput)
        |> with_deposit()
        |> insert()

      build(:txoutput, owner: txoutput.owner)
      |> with_deposit()
      |> with_spending_transaction()
      |> insert()

      build(:txoutput, owner: txoutput.owner)
      |> with_deposit()
      |> with_standard_exit()
      |> insert()

      assert length(DB.TxOutput.get_utxos(txoutput.owner)) == 1

      assert DB.Repo.one(
               from(t in DB.TxOutput,
                 where: t.owner == ^txoutput.owner,
                 select: count(t.child_chain_utxohash)
               )
             ) == 3
    end
  end
end
