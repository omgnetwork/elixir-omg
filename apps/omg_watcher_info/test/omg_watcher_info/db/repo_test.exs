# Copyright 2019 OmiseGO Pte Ltd
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

defmodule OMG.WatcherInfo.DB.RepoTest do
  use OMG.WatcherInfo.Test.DBTestCase, async: true

  import Ecto.Query, only: [from: 2]

  import OMG.WatcherInfo.Factory

  # test "insert_all_chunked adds inserted_at and updated_at timestamps correctly" do
  #   blknum = 5432

  #   block = %{blknum: blknum, eth_height: 1, hash: "#1000", timestamp: 1}

  #   DB.Repo.insert_all_chunked(OMG.Watcher.DB.Block, [block])

  #   db_block = DB.Repo.one(from(block in OMG.Watcher.DB.Block, where: block.blknum == ^blknum))

  #   # on insert inserted_at and updated_at should be approximately equal or updated_at will be greater
  #   assert DateTime.compare(db_block.inserted_at, db_block.updated_at) == :lt ||
  #            DateTime.compare(db_block.inserted_at, db_block.updated_at) == :eq

  #   DB.Repo.delete(db_block)
  # end

  test "factory works" do
    block = insert(:block)

    IO.inspect(block, label: "block")
# Copyright 2019 OmiseGO Pte Ltd
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

defmodule OMG.WatcherInfo.DB.RepoTest do
  use ExUnitFixtures
  use ExUnit.Case, async: false
  use OMG.Fixtures

  import OMG.WatcherInfo.Factory

  alias OMG.WatcherInfo.DB

  alias OMG.Utxo
  require Utxo

  describe "DB.Repo.insert_all_chunked/3" do
    # a special test for insert_all_chunked/3 is here because under the hood it calls insert_all/2. using
    # insert_all/3 with a queryable means that certain autogenerated columns, such as inserted_at and
    # updated_at, will not be inserted as they would be if you used a plain insert. More info
    # is here: https://hexdocs.pm/ecto/Ecto.Repo.html#c:insert_all/3
    @tag fixtures: [:phoenix_ecto_sandbox]
    test "insert_all_chunked adds inserted_at and updated_at timestamps correctly" do
      txoutput = params_for(:txoutput)

      # insert_all doesn't support associations so remove them
      txoutput = Map.drop(txoutput, [:ethevents])

      DB.Repo.insert_all_chunked(OMG.WatcherInfo.DB.TxOutput, [txoutput])

      txoutput_with_dates =
        DB.TxOutput.get_by_position(Utxo.position(txoutput.blknum, txoutput.txindex, txoutput.oindex))

      assert txoutput_with_dates.inserted_at != nil
      assert txoutput_with_dates.updated_at != nil
      assert DateTime.compare(txoutput_with_dates.inserted_at, txoutput_with_dates.updated_at) == :eq
    end
  end

  describe "OMG.WatcherInfo.DB.TxOutput.spend_utxos/3" do
    # a special test for spend_utxos/3 is here because under the hood it calls update_all/3. using
    # update_all/3 with a queryable means that certain autogenerated columns, such as inserted_at and
    # updated_at, will not be updated as they would be if you used a plain update. More info
    # is here: https://hexdocs.pm/ecto/Ecto.Repo.html#c:update_all/3
    @tag fixtures: [:phoenix_ecto_sandbox]
    test "spend_utxos updates the updated_at timestamp correctly" do
      txoutput = params_for(:txoutput)

      # insert_all doesn't support associations so remove them
      txoutput = Map.drop(txoutput, [:ethevents])

      DB.Repo.insert_all_chunked(DB.TxOutput, [txoutput])

      txoutput_with_dates =
        DB.TxOutput.get_by_position(Utxo.position(txoutput.blknum, txoutput.txindex, txoutput.oindex))

      utxo_inputs = [
        {
          Utxo.position(txoutput.blknum, txoutput.txindex, txoutput.oindex),
          nil,
          nil
        }
      ]

      DB.TxOutput.spend_utxos(utxo_inputs)

      txoutput_with_updated_updated_at_date =
        DB.TxOutput.get_by_position(Utxo.position(txoutput.blknum, txoutput.txindex, txoutput.oindex))

      assert txoutput_with_updated_updated_at_date.inserted_at != nil
      assert txoutput_with_updated_updated_at_date.updated_at != nil
      assert DateTime.compare(txoutput_with_dates.inserted_at, txoutput_with_updated_updated_at_date.inserted_at) == :eq

      assert DateTime.compare(
               txoutput_with_updated_updated_at_date.inserted_at,
               txoutput_with_updated_updated_at_date.updated_at
             ) == :lt
    end
  end

  describe "OMG.WatcherInfo.DB.Repo insert and update" do
    @tag fixtures: [:phoenix_ecto_sandbox]
    test "entity inserts correctly set inserted_at and updated_at fields" do
      block = insert(:block)
      transaction = insert(:transaction)
      txoutput = insert(:txoutput)
      ethevent = insert(:ethevent)

      assert block.inserted_at != nil
      assert block.updated_at != nil

      assert transaction.inserted_at != nil
      assert transaction.updated_at != nil

      assert txoutput.inserted_at != nil
      assert txoutput.updated_at != nil

      assert ethevent.inserted_at != nil
      assert ethevent.updated_at != nil
    end

    @tag fixtures: [:phoenix_ecto_sandbox]
    test "entity updates correctly update the updated_at" do
      block = insert(:block)
      transaction = insert(:transaction)
      txoutput = insert(:txoutput)
      ethevent = insert(:ethevent)

      {:ok, updated_block} = DB.Repo.update(Ecto.Changeset.change(block), force: true)

      assert DateTime.compare(block.inserted_at, updated_block.inserted_at) == :eq
      assert DateTime.compare(block.updated_at, updated_block.updated_at) == :lt

      {:ok, updated_transaction} = DB.Repo.update(Ecto.Changeset.change(transaction), force: true)

      assert DateTime.compare(transaction.inserted_at, updated_transaction.inserted_at) == :eq
      assert DateTime.compare(transaction.updated_at, updated_transaction.updated_at) == :lt

      {:ok, updated_txoutput} = DB.Repo.update(Ecto.Changeset.change(txoutput), force: true)

      assert DateTime.compare(txoutput.inserted_at, updated_txoutput.inserted_at) == :eq
      assert DateTime.compare(txoutput.updated_at, updated_txoutput.updated_at) == :lt

      {:ok, updated_ethevent} = DB.Repo.update(Ecto.Changeset.change(ethevent), force: true)

      assert DateTime.compare(ethevent.inserted_at, updated_ethevent.inserted_at) == :eq
      assert DateTime.compare(ethevent.updated_at, updated_ethevent.updated_at) == :lt
    end
  end
end
