apps/omg_performance/
apps/omg/test
apps/omg_eth/test


# TODO
Expression produces a value of type 'error' | 'excluded' | 'ignored' | 'unsampled' | {'ok',binary() | pid() | #{'__struct__':='Elixir.Task', 'owner':='nil' | pid(), 'pid':='nil' | pid(), 'ref':='nil' | reference()}}, but this value is unmatched
The success typing for 'Elixir.Jason.Encoder.OMG.Watcher.DB.Transaction':'__impl__'/1 implies that the function might also return 'Elixir.Jason.Encoder' | 'Elixir.Jason.Encoder.OMG.Watcher.DB.Transaction' but the specification return is 'Elixir.OMG.Watcher.DB.Transaction'
The success typing for 'Elixir.OMG.ChildChain.BlockQueue.Core':first_to_mined/1 implies that the function might also return float() but the specification return is pos_integer()
The success typing for 'Elixir.OMG.Crypto':decode_address/1 implies that the function might also return 'error' but the specification return is {'error','bad_address_encoding'} | {'ok',<<_:160>>}
The success typing for 'Elixir.OMG.DB.LevelDB.Core':decode_values/2 implies that the function might also return {'error',[any()]} but the specification return is {'ok',[any()]}
The success typing for 'Elixir.OMG.DB.LevelDB.Server':get/2 implies that the function might also return {'error',_} but the specification return is 'not_found' | {'ok',binary()}
The success typing for 'Elixir.OMG.DB.LevelDB.Server':init_storage/1 implies that the function might also return 'false' but the specification return is 'ok' | {'error',atom()}
The success typing for 'Elixir.OMG.DB.RocksDB.Server':get/2 implies that the function might also return {'error',_} but the specification return is 'not_found' | {'ok',binary()}
The success typing for 'Elixir.OMG.DB.RocksDB.Server':init_storage/1 implies that the function might also return 'false' but the specification return is 'ok' | {'error',atom()}
The success typing for 'Elixir.OMG.Eth':send_transaction/2 implies that the function might also return #{<<_:48,_:_*8>>=>_} but the specification return is {'error',_} | {'ok',<<_:256>>}
The success typing for 'Elixir.OMG.Eth.RootChain':get_root_deployment_height/2 implies that the function might also return #{<<_:48,_:_*8>>=>_} but the specification return is {'error',atom() | binary() | map()} | {'ok',integer()}
The success typing for 'Elixir.OMG.State.Transaction.Recovered':recover_from/1 implies that the function might also return 'false' but the specification return is {'error','bad_signature_length' | 'duplicate_inputs' | 'malformed_transaction' | 'malformed_transaction_rlp' | 'missing_signature' | 'signature_corrupt'} | {'ok',#{'__struct__':='Elixir.OMG.State.Transaction.Recovered', 'signed_tx':=#{'__struct__':='Elixir.OMG.State.Transaction.Signed', 'raw_tx':=#{'__struct__':='Elixir.OMG.State.Transaction', 'inputs':=[#{'blknum':=non_neg_integer(), 'oindex':=non_neg_integer(), 'txindex':=non_neg_integer()}], 'metadata':='nil' | binary(), 'outputs':=[#{'amount':=non_neg_integer(), 'currency':=<<_:160>>, 'owner':=<<_:160>>}]}, 'signed_tx_bytes':='nil' | binary(), 'sigs':=[<<_:520>>]}, 'spenders':=[<<_:160>>], 'tx_hash':=<<_:256>>}}
The success typing for 'Elixir.OMG.Watcher.BlockGetter.Core':handle_downloaded_block/2 implies that the function might also return 'false' but the specification return is {'error' | 'ok' | {'error','bad_returned_hash' | 'bad_signature_length' | 'duplicate_inputs' | 'incorrect_hash' | 'malformed_transaction' | 'malformed_transaction_rlp' | 'missing_signature' | 'signature_corrupt' | 'withholding'},'duplicate' | 'unexpected_block' | #{'__struct__':='Elixir.OMG.Watcher.BlockGetter.Core', 'chain_status':=_, 'config':=_, 'events':=_, 'last_applied_block':=_, 'last_block_persisted_from_prev_run':=_, 'num_of_highest_block_being_downloaded':=_, 'number_of_blocks_being_downloaded':=_, 'potential_block_withholdings':=_, 'synced_height':=_, 'unapplied_blocks':=_}}
The success typing for 'Elixir.OMG.Watcher.ExitProcessor.Core':get_competitor_for_ife/3 implies that the function might also return 'false' but the specification return is {'error','competitor_not_found' | 'no_viable_competitor_found'} | {'ok',#{'competing_input_index':=non_neg_integer(), 'competing_proof':=binary(), 'competing_sig':=binary(), 'competing_tx_pos':={'utxo_position',non_neg_integer(),non_neg_integer(),non_neg_integer()}, 'competing_txbytes':=binary(), 'in_flight_input_index':=non_neg_integer(), 'in_flight_txbytes':=binary()}}
The success typing for 'Elixir.OMG.Watcher.ExitProcessor.Core':prove_canonical_for_ife/2 implies that the function might also return 'false' but the specification return is {'error','no_viable_canonical_proof_found'} | {'ok',#{'in_flight_proof':=binary(), 'in_flight_tx_pos':={'utxo_position',non_neg_integer(),non_neg_integer(),non_neg_integer()}, 'in_flight_txbytes':=binary()}}
The success typing for 'Elixir.OMG.Watcher.ExitProcessor.InFlightExitInfo':challenge/2 implies that the function might also return #{'__struct__':='Elixir.OMG.Watcher.ExitProcessor.InFlightExitInfo', 'is_canonical':='false', 'oldest_competitor':={'utxo_position',non_neg_integer(),non_neg_integer(),char()}, _=>_} but the specification return is {'error','competitor_too_young'} | {'ok',#{'__struct__':='Elixir.OMG.Watcher.ExitProcessor.InFlightExitInfo', 'contract_id':=<<_:192>>, 'contract_tx_pos':='nil' | {'utxo_position',non_neg_integer(),non_neg_integer(),non_neg_integer()}, 'eth_height':=pos_integer(), 'exit_map':=#{non_neg_integer()=>#{'is_finalized':=boolean(), 'is_piggybacked':=boolean()}}, 'is_active':=boolean(), 'is_canonical':=boolean(), 'oldest_competitor':='nil' | {'utxo_position',non_neg_integer(),non_neg_integer(),non_neg_integer()}, 'timestamp':=non_neg_integer(), 'tx':=#{'__struct__':='Elixir.OMG.State.Transaction.Sign
The success typing for 'Elixir.OMG.Watcher.ExitProcessor.InFlightExitInfo':challenge/2 implies that the function might also return #{'__struct__':='Elixir.OMG.Watcher.ExitProcessor.InFlightExitInfo', 'is_canonical':='false', 'oldest_competitor':={'utxo_position',non_neg_integer(),non_neg_integer(),non_neg_integer()}, _=>_} but the specification return is {'error','competitor_too_young'} | {'ok',#{'__struct__':='Elixir.OMG.Watcher.ExitProcessor.InFlightExitInfo', 'contract_id':=<<_:192>>, 'contract_tx_pos':='nil' | {'utxo_position',non_neg_integer(),non_neg_integer(),non_neg_integer()}, 'eth_height':=pos_integer(), 'exit_map':=#{non_neg_integer()=>#{'is_finalized':=boolean(), 'is_piggybacked':=boolean()}}, 'is_active':=boolean(), 'is_canonical':=boolean(), 'oldest_competitor':='nil' | {'utxo_position',non_neg_integer(),non_neg_integer(),non_neg_integer()}, 'timestamp':=non_neg_integer(), 'tx':=#{'__struct__':='Elixir.OMG.State.Trans
The success typing for 'Elixir.Phoenix.Param.OMG.Watcher.DB.Block':'__impl__'/1 implies that the function might also return 'Elixir.Phoenix.Param' | 'Elixir.Phoenix.Param.OMG.Watcher.DB.Block' but the specification return is 'Elixir.OMG.Watcher.DB.Block'
The success typing for 'Elixir.Phoenix.Param.OMG.Watcher.DB.EthEvent':'__impl__'/1 implies that the function might also return 'Elixir.Phoenix.Param' | 'Elixir.Phoenix.Param.OMG.Watcher.DB.EthEvent' but the specification return is 'Elixir.OMG.Watcher.DB.EthEvent'
The success typing for 'Elixir.Phoenix.Param.OMG.Watcher.DB.Transaction':'__impl__'/1 implies that the function might also return 'Elixir.Phoenix.Param' | 'Elixir.Phoenix.Param.OMG.Watcher.DB.Transaction' but the specification return is 'Elixir.OMG.Watcher.DB.Transaction'
Type specification 'Elixir.OMG.Block':hashed_txs_at(['Elixir.OMG.State.Transaction.Recovered':t()],non_neg_integer()) -> t() is a subtype of the success typing: 'Elixir.OMG.Block':hashed_txs_at(_,_) -> #{'__struct__':='Elixir.OMG.Block', 'hash':=binary(), 'number':=_, 'transactions':=[any()]}
Type specification 'Elixir.OMG.Block':inclusion_proof(t() | ['Elixir.OMG.State.Transaction.Signed':tx_bytes()],non_neg_integer()) -> binary() is a subtype of the success typing: 'Elixir.OMG.Block':inclusion_proof(maybe_improper_list() | #{'__struct__':='Elixir.OMG.Block', 'transactions':=maybe_improper_list() | #{'__struct__':='Elixir.OMG.Block', 'transactions':=maybe_improper_list() | #{'__struct__':='Elixir.OMG.Block', 'transactions':=maybe_improper_list() | map(), _=>_}, _=>_}, _=>_},non_neg_integer()) -> binary()
Type specification 'Elixir.OMG.ChildChain':get_block(hash::binary()) -> {'ok',#{'hash':=binary(),'transactions':=[any()],'blknum':=integer()}} | {'error','not_found' | 'internal_error'} is a subtype of the success typing: 'Elixir.OMG.ChildChain':get_block(_) -> any()
Type specification 'Elixir.OMG.ChildChain':submit(transaction::binary()) -> {'ok',#{'txhash':='Elixir.OMG.State.Transaction':tx_hash(),'blknum':=pos_integer(),'txindex':=non_neg_integer()}} | {'error',submit_error()} is a subtype of the success typing: 'Elixir.OMG.ChildChain':submit(_) -> any()
Type specification 'Elixir.OMG.ChildChain.BlockQueue.Core':child_block_nums_to_init_with(non_neg_integer(),non_neg_integer(),pos_integer(),non_neg_integer()) -> [any()] is not equal to the success typing: 'Elixir.OMG.ChildChain.BlockQueue.Core':child_block_nums_to_init_with(number(),_,number(),number()) -> [integer()]
Type specification 'Elixir.OMG.ChildChain.BlockQueue.Core':enqueue_block('Elixir.OMG.ChildChain.BlockQueue.Core':t(),'Elixir.OMG.ChildChain.BlockQueue':hash(),'Elixir.OMG.ChildChain.BlockQueue':plasma_block_num(),pos_integer()) -> 'Elixir.OMG.ChildChain.BlockQueue.Core':t() | {'error','unexpected_block_number'} is not equal to the success typing: 'Elixir.OMG.ChildChain.BlockQueue.Core':enqueue_block(atom() | #{'child_block_interval':=number(), 'formed_child_block_num':=number(), _=>_},_,_,_) -> {'error','unexpected_block_number'} | #{'blocks':=map(), 'child_block_interval':=number(), 'formed_child_block_num':=number(), 'last_enqueued_block_at_height':=_, 'wait_for_enqueue':='false', _=>_}
Type specification 'Elixir.OMG.ChildChain.BlockQueue.Core':enqueue_existing_blocks('Elixir.OMG.ChildChain.BlockQueue.Core':t(),'Elixir.OMG.ChildChain.BlockQueue':hash(),[{pos_integer(),'Elixir.OMG.ChildChain.BlockQueue':hash()}]) -> {'ok','Elixir.OMG.ChildChain.BlockQueue.Core':t()} | {'error','contract_ahead_of_db' | 'mined_blknum_not_found_in_db' | 'hashes_dont_match'} is not equal to the success typing: 'Elixir.OMG.ChildChain.BlockQueue.Core':enqueue_existing_blocks(#{'__struct__':='Elixir.OMG.ChildChain.BlockQueue.Core', 'blocks':=#{}, 'chain_start_parent_height':=_, 'child_block_interval':=_, 'finality_threshold':=_, 'formed_child_block_num':=0, 'gas_price_adj_params':=#{'__struct__':='Elixir.OMG.ChildChain.BlockQueue.GasPriceAdjustment', 'eth_gap_without_child_blocks':=2, 'gas_price_lowering_factor':=float(), 'gas_price_raising_factor':=float(), 'last_block_mined':='nil', 'max_gas_price':=20000000000}, 'gas_price_to_use':=20000000000,
Type specification 'Elixir.OMG.ChildChain.BlockQueue.Core':process_submit_result('Elixir.OMG.ChildChain.BlockQueue.Core.BlockSubmission':t(),submit_result_t(),'Elixir.OMG.ChildChain.BlockQueue.Core.BlockSubmission':plasma_block_num()) -> 'ok' | {'error',atom()} is not equal to the success typing: 'Elixir.OMG.ChildChain.BlockQueue.Core':process_submit_result(_,{'error',map()} | {'ok',_},_) -> 'ok' | {'error','account_locked' | 'nonce_too_low'}
Type specification 'Elixir.OMG.ChildChain.BlockQueue.Core':set_mined('Elixir.OMG.ChildChain.BlockQueue.Core':t(),'Elixir.OMG.ChildChain.BlockQueue':plasma_block_num()) -> 'Elixir.OMG.ChildChain.BlockQueue.Core':t() is a subtype of the success typing: 'Elixir.OMG.ChildChain.BlockQueue.Core':set_mined(#{'blocks':=_, 'child_block_interval':=number(), 'finality_threshold':=number(), 'formed_child_block_num':=_, 'mined_child_block_num':=_, 'parent_height':=_, _=>_},number()) -> #{'blocks':=map(), 'child_block_interval':=number(), 'finality_threshold':=number(), 'formed_child_block_num':=_, 'mined_child_block_num':=number(), 'parent_height':=_, _=>_}
Type specification 'Elixir.OMG.ChildChain.BlockQueue.Core':to_mined_block_filter('Elixir.OMG.ChildChain.BlockQueue.Core':t()) -> fun(({pos_integer(),'Elixir.OMG.ChildChain.BlockQueue.Core.BlockSubmission':t()}) -> boolean()) is a subtype of the success typing: 'Elixir.OMG.ChildChain.BlockQueue.Core':to_mined_block_filter(#{'blocks':=_, 'formed_child_block_num':=_, _=>_}) -> fun(({_,_}) -> boolean())
Type specification 'Elixir.OMG.ChildChain.BlockQueue.Core':new(elixir:keyword()) -> {'ok','Elixir.OMG.ChildChain.BlockQueue.Core':t()} | {'error','contract_ahead_of_db' | 'mined_blknum_not_found_in_db' | 'hashes_dont_match'} is not equal to the success typing: 'Elixir.OMG.ChildChain.BlockQueue.Core':new([{'chain_start_parent_height' | 'child_block_interval' | 'finality_threshold' | 'known_hashes' | 'last_enqueued_block_at_height' | 'mined_child_block_num' | 'minimal_enqueue_block_gap' | 'parent_height' | 'top_mined_hash','nil' | <<_:256>> | [{_,_}] | non_neg_integer()},...]) -> {'error','contract_ahead_of_db' | 'hashes_dont_match' | 'mined_blknum_not_found_in_db'} | {'ok',#{'__struct__':='Elixir.OMG.ChildChain.BlockQueue.Core', 'blocks':=#{pos_integer()=>map()}, 'chain_start_parent_height':=pos_integer(), 'child_block_interval':=pos_integer(), 'finality_threshold':=pos_integer(), 'formed_child_block_num':=non_neg_integer(), 'gas_price_adj_params':=#{'__struct__':='Elixir.OMG.ChildChain.BlockQueue.GasPriceAdjustment', 'eth_gap_without_child_blocks':=pos_integer(), 'gas_price_lowering_factor':=float(), 'gas_price_raising_factor':=float(), 'last_block_mined':='nil' | tuple(), 'max_gas_price':=pos_integer()}, 'gas_price_to_use':=pos_integer(), 'last_enqueued_block_at_height':=pos_integer(), 'last_parent_height':=non_neg_integer(), 'mined_child_block_num':=non_neg_integer(), 'minimal_enqueue_block_gap':=pos_integer(), 'parent_height':='nil' | non_neg_integer(), 'wait_for_enqueue':=boolean()}}
Type specification 'Elixir.OMG.ChildChain.BlockQueue.Core':set_ethereum_status('Elixir.OMG.ChildChain.BlockQueue.Core':t(),'Elixir.OMG.ChildChain.BlockQueue':eth_height(),'Elixir.OMG.ChildChain.BlockQueue':plasma_block_num(),boolean()) -> {'do_form_block','Elixir.OMG.ChildChain.BlockQueue.Core':t()} | {'dont_form_block','Elixir.OMG.ChildChain.BlockQueue.Core':t()} is not equal to the success typing: 'Elixir.OMG.ChildChain.BlockQueue.Core':set_ethereum_status(#{'parent_height':=_, _=>_},'nil' | non_neg_integer(),non_neg_integer(),boolean()) -> {'do_form_block',#{'__struct__':='Elixir.OMG.ChildChain.BlockQueue.Core', 'blocks':=#{pos_integer()=>map()}, 'chain_start_parent_height':=pos_integer(), 'child_block_interval':=pos_integer(), 'finality_threshold':=pos_integer(), 'formed_child_block_num':=non_neg_integer(), 'gas_price_adj_params':=#{'__struct__':='Elixir.OMG.ChildChain.BlockQueue.GasPriceAdjustment', 'eth_gap_without_child_blocks':=pos_integer(), 'gas_price_lowering_factor':=float(), 'gas_price_raising_factor':=float(), 'last_block_mined':=tuple(), 'max_gas_price':=pos_integer()}, 'gas_price_to_use':=pos_integer(), 'last_enqueued_block_at_height':=pos_integer(), 'last_parent_height':=non_neg_integer(), 'mined_child_block_num':=non_neg_integer(), 'minimal_enqueue_block_gap':=pos_integer(), 'parent_height':=non_neg_integer(), 'wait_for_enqueue':='true'}} | {'dont_form_block',#{'__struct__':='Elixir.OMG.ChildChain.BlockQueue.Core', 'blocks':=#{pos_integer()=>map()}, 'chain_start_parent_height':=pos_integer(), 'child_block_interval':=pos_integer(), 'finality_threshold':=pos_integer(), 'formed_child_block_num':=non_neg_integer(), 'gas_price_adj_params':=#{'__struct__':='Elixir.OMG.ChildChain.BlockQueue.GasPriceAdjustment', 'eth_gap_without_child_blocks':=pos_integer(), 'gas_price_lowering_factor':=float(), 'gas_price_raising_factor':=float(), 'last_block_mined':=tuple(), 'max_gas_price':=pos_integer()}, 'gas_price_to_use':=pos_integer(), 'last_enqueued_block_at_height':=pos_integer(), 'last_parent_height':=non_neg_integer(), 'mined_child_block_num':=non_neg_integer(), 'minimal_enqueue_block_gap':=pos_integer(), 'parent_height':=non_neg_integer(), 'wait_for_enqueue':=boolean()}}
Type specification 'Elixir.OMG.ChildChain.BlockQueue.Core':adjust_gas_price('Elixir.OMG.ChildChain.BlockQueue.Core':t()) -> 'Elixir.OMG.ChildChain.BlockQueue.Core':t() is not equal to the success typing: 'Elixir.OMG.ChildChain.BlockQueue.Core':adjust_gas_price(#{'__struct__':='Elixir.OMG.ChildChain.BlockQueue.Core', 'blocks':=#{pos_integer()=>map()}, 'chain_start_parent_height':=pos_integer(), 'child_block_interval':=pos_integer(), 'finality_threshold':=pos_integer(), 'formed_child_block_num':=non_neg_integer(), 'gas_price_adj_params':=#{'__struct__':='Elixir.OMG.ChildChain.BlockQueue.GasPriceAdjustment', 'eth_gap_without_child_blocks':=pos_integer(), 'gas_price_lowering_factor':=float(), 'gas_price_raising_factor':=float(), 'last_block_mined':='nil' | tuple(), 'max_gas_price':=pos_integer()}, 'gas_price_to_use':=pos_integer(), 'last_enqueued_block_at_height':=pos_integer(), 'last_parent_height':=non_neg_integer(), 'mined_child_block_num':=non_neg_integer(), 'minimal_enqueue_block_gap':=pos_integer(), 'parent_height':='nil' | non_neg_integer(), 'wait_for_enqueue':=boolean()}) -> #{'__struct__':='Elixir.OMG.ChildChain.BlockQueue.Core', 'blocks':=#{pos_integer()=>map()}, 'chain_start_parent_height':=pos_integer(), 'child_block_interval':=pos_integer(), 'finality_threshold':=pos_integer(), 'formed_child_block_num':=non_neg_integer(), 'gas_price_adj_params':=#{'last_block_mined':=tuple(), _=>_}, 'gas_price_to_use':=pos_integer(), 'last_enqueued_block_at_height':=pos_integer(), 'last_parent_height':='nil' | non_neg_integer(), 'mined_child_block_num':=non_neg_integer(), 'minimal_enqueue_block_gap':=pos_integer(), 'parent_height':='nil' | non_neg_integer(), 'wait_for_enqueue':=boolean()}
Type specification 'Elixir.OMG.ChildChain.BlockQueue.Core':calculate_gas_price('Elixir.OMG.ChildChain.BlockQueue.Core':t()) -> pos_integer() is not equal to the success typing: 'Elixir.OMG.ChildChain.BlockQueue.Core':calculate_gas_price(#{'__struct__':='Elixir.OMG.ChildChain.BlockQueue.Core', 'blocks':=#{pos_integer()=>map()}, 'chain_start_parent_height':=pos_integer(), 'child_block_interval':=pos_integer(), 'finality_threshold':=pos_integer(), 'formed_child_block_num':=non_neg_integer(), 'gas_price_adj_params':=#{'__struct__':='Elixir.OMG.ChildChain.BlockQueue.GasPriceAdjustment', 'eth_gap_without_child_blocks':=pos_integer(), 'gas_price_lowering_factor':=float(), 'gas_price_raising_factor':=float(), 'last_block_mined':={_,_}, 'max_gas_price':=pos_integer()}, 'gas_price_to_use':=pos_integer(), 'last_enqueued_block_at_height':=pos_integer(), 'last_parent_height':=non_neg_integer(), 'mined_child_block_num':=non_neg_integer(), 'minimal_enqueue_block_gap':=pos_integer(), 'parent_height':='nil' | non_neg_integer(), 'wait_for_enqueue':=boolean()}) -> any()
Type specification 'Elixir.OMG.ChildChain.BlockQueue.Core':update_last_checked_mined_block_num('Elixir.OMG.ChildChain.BlockQueue.Core':t()) -> 'Elixir.OMG.ChildChain.BlockQueue.Core':t() is not equal to the success typing: 'Elixir.OMG.ChildChain.BlockQueue.Core':update_last_checked_mined_block_num(#{'__struct__':='Elixir.OMG.ChildChain.BlockQueue.Core', 'blocks':=#{pos_integer()=>map()}, 'chain_start_parent_height':=pos_integer(), 'child_block_interval':=pos_integer(), 'finality_threshold':=pos_integer(), 'formed_child_block_num':=non_neg_integer(), 'gas_price_adj_params':=#{'__struct__':='Elixir.OMG.ChildChain.BlockQueue.GasPriceAdjustment', 'eth_gap_without_child_blocks':=pos_integer(), 'gas_price_lowering_factor':=float(), 'gas_price_raising_factor':=float(), 'last_block_mined':={_,_}, 'max_gas_price':=pos_integer()}, 'gas_price_to_use':=pos_integer(), 'last_enqueued_block_at_height':=pos_integer(), 'last_parent_height':=non_neg_integer(), 'mined_child_block_num':=non_neg_integer(), 'minimal_enqueue_block_gap':=pos_integer(), 'parent_height':='nil' | non_neg_integer(), 'wait_for_enqueue':=boolean()}) -> #{'__struct__':='Elixir.OMG.ChildChain.BlockQueue.Core', 'blocks':=#{pos_integer()=>map()}, 'chain_start_parent_height':=pos_integer(), 'child_block_interval':=pos_integer(), 'finality_threshold':=pos_integer(), 'formed_child_block_num':=non_neg_integer(), 'gas_price_adj_params':=#{'last_block_mined':={_,_}, _=>_}, 'gas_price_to_use':=pos_integer(), 'last_enqueued_block_at_height':=pos_integer(), 'last_parent_height':=non_neg_integer(), 'mined_child_block_num':=non_neg_integer(), 'minimal_enqueue_block_gap':=pos_integer(), 'parent_height':='nil' | non_neg_integer(), 'wait_for_enqueue':=boolean()}
Type specification 'Elixir.OMG.ChildChain.BlockQueue.Core':get_blocks_to_submit('Elixir.OMG.ChildChain.BlockQueue.Core':t()) -> ['Elixir.OMG.ChildChain.BlockQueue':encoded_signed_tx()] is a subtype of the success typing: 'Elixir.OMG.ChildChain.BlockQueue.Core':get_blocks_to_submit(#{'__struct__':='Elixir.OMG.ChildChain.BlockQueue.Core', 'blocks':=#{pos_integer()=>map()}, 'chain_start_parent_height':=pos_integer(), 'child_block_interval':=pos_integer(), 'finality_threshold':=pos_integer(), 'formed_child_block_num':=non_neg_integer(), 'gas_price_adj_params':=#{'__struct__':='Elixir.OMG.ChildChain.BlockQueue.GasPriceAdjustment', 'eth_gap_without_child_blocks':=pos_integer(), 'gas_price_lowering_factor':=float(), 'gas_price_raising_factor':=float(), 'last_block_mined':='nil' | tuple(), 'max_gas_price':=pos_integer()}, 'gas_price_to_use':=pos_integer(), 'last_enqueued_block_at_height':=pos_integer(), 'last_parent_height':=non_neg_integer(), 'mined_child_block_num':=non_neg_integer(), 'minimal_enqueue_block_gap':=pos_integer(), 'parent_height':='nil' | non_neg_integer(), 'wait_for_enqueue':=boolean()}) -> [any()]
Type specification 'Elixir.OMG.ChildChain.BlockQueue.Core':'should_form_block?'('Elixir.OMG.ChildChain.BlockQueue.Core':t(),boolean()) -> boolean() is not equal to the success typing: 'Elixir.OMG.ChildChain.BlockQueue.Core':'should_form_block?'(#{'__struct__':='Elixir.OMG.ChildChain.BlockQueue.Core', 'blocks':=#{pos_integer()=>map()}, 'chain_start_parent_height':=pos_integer(), 'child_block_interval':=pos_integer(), 'finality_threshold':=pos_integer(), 'formed_child_block_num':=non_neg_integer(), 'gas_price_adj_params':=#{'__struct__':='Elixir.OMG.ChildChain.BlockQueue.GasPriceAdjustment', 'eth_gap_without_child_blocks':=pos_integer(), 'gas_price_lowering_factor':=float(), 'gas_price_raising_factor':=float(), 'last_block_mined':=tuple(), 'max_gas_price':=pos_integer()}, 'gas_price_to_use':=pos_integer(), 'last_enqueued_block_at_height':=pos_integer(), 'last_parent_height':=non_neg_integer(), 'mined_child_block_num':=non_neg_integer(), 'minimal_enqueue_block_gap':=pos_integer(), 'parent_height':=non_neg_integer(), 'wait_for_enqueue':=boolean()},_) -> boolean()
Type specification 'Elixir.OMG.ChildChain.FeeServer':transaction_fees() -> {'ok','Elixir.OMG.Fees':fee_t()} is a subtype of the success typing: 'Elixir.OMG.ChildChain.FeeServer':transaction_fees() -> {'ok',_}
Type specification 'Elixir.OMG.ChildChain.FreshBlocks':get(block_hash::binary()) -> {'ok','Elixir.OMG.Block':t()} | {'error','not_found' | any()} is a subtype of the success typing: 'Elixir.OMG.ChildChain.FreshBlocks':get(_) -> any()
Type specification 'Elixir.OMG.ChildChain.FreshBlocks':push('Elixir.OMG.Block':t()) -> 'ok' is a subtype of the success typing: 'Elixir.OMG.ChildChain.FreshBlocks':push(_) -> 'ok'
Type specification 'Elixir.OMG.ChildChain.Monitor':pop_child_from_dead_pid(pid(),['Elixir.OMG.ChildChain.Monitor.Child':t()]) -> {'Elixir.OMG.ChildChain.Monitor.Child':t(),['Elixir.OMG.ChildChain.Monitor.Child':t()]} | {'nil',['Elixir.OMG.ChildChain.Monitor.Child':t()]} is a subtype of the success typing: 'Elixir.OMG.ChildChain.Monitor':pop_child_from_dead_pid(_,[any()]) -> {_,[any()]}
Type specification 'Elixir.OMG.Crypto':recover_address(hash_t(),sig_t()) -> {'ok',address_t()} | {'error','signature_corrupt' | atom()} is a supertype of the success typing: 'Elixir.OMG.Crypto':recover_address(<<_:256>>,<<_:520>>) -> {'error','signature_corrupt'} | {'ok',<<_:160>>}
Type specification 'Elixir.OMG.Crypto':recover_public(<<_:256>>,sig_t()) -> {'ok',<<_:512>>} | {'error','signature_corrupt' | atom()} is not equal to the success typing: 'Elixir.OMG.Crypto':recover_public(<<_:256>>,<<_:520>>) -> {'error','signature_corrupt' | binary()} | {'ok',<<_:512>>}
Type specification 'Elixir.OMG.DB.LevelDB':blocks(block_to_fetch::[any()],atom()) -> {'ok',[any()]} | {'error',any()} is a subtype of the success typing: 'Elixir.OMG.DB.LevelDB':blocks(_,_) -> any()
Type specification 'Elixir.OMG.DB.LevelDB':exit_info({pos_integer(),non_neg_integer(),non_neg_integer()},atom()) -> {'ok',map()} | {'error',atom()} is a subtype of the success typing: 'Elixir.OMG.DB.LevelDB':exit_info(_,atom() | pid() | {atom(),_} | {'via',atom(),_}) -> any()
Type specification 'Elixir.OMG.DB.LevelDB':spent_blknum(utxo_pos_db_t(),atom()) -> {'ok',pos_integer()} | {'error',atom()} is a subtype of the success typing: 'Elixir.OMG.DB.LevelDB':spent_blknum(_,atom() | pid() | {atom(),_} | {'via',atom(),_}) -> any()
Type specification 'Elixir.OMG.DB.LevelDB.Core':decode_value({'ok',binary()} | 'not_found',atom()) -> {'ok',term()} | {'error',term()} is a subtype of the success typing: 'Elixir.OMG.DB.LevelDB.Core':decode_value(_,_) -> {'error',_} | {'ok',_}
Type specification 'Elixir.OMG.DB.LevelDB.Recorder':update_multiread(atom()) -> integer() is a subtype of the success typing: 'Elixir.OMG.DB.LevelDB.Recorder':update_multiread(atom() | ets:tid()) -> integer()
Type specification 'Elixir.OMG.DB.LevelDB.Recorder':update_read(atom()) -> integer() is a subtype of the success typing: 'Elixir.OMG.DB.LevelDB.Recorder':update_read(atom() | ets:tid()) -> integer()
Type specification 'Elixir.OMG.DB.LevelDB.Recorder':update_write(atom()) -> integer() is a subtype of the success typing: 'Elixir.OMG.DB.LevelDB.Recorder':update_write(atom() | ets:tid()) -> integer()
Type specification 'Elixir.OMG.DB.LevelDB.Server':write('Elixir.Exleveldb':write_actions(),t()) -> 'ok' | {'error',any()} is not equal to the success typing: 'Elixir.OMG.DB.LevelDB.Server':write([any()],#{'__struct__':='Elixir.OMG.DB.LevelDB.Server', 'db_ref':=eleveldb:db_ref(), 'name':=atom(), _=>_}) -> 'ok' | {'error',_}
Type specification 'Elixir.OMG.DB.RocksDB':blocks(block_to_fetch::[any()],atom()) -> {'ok',[any()]} | {'error',any()} is a subtype of the success typing: 'Elixir.OMG.DB.RocksDB':blocks(_,_) -> any()
Type specification 'Elixir.OMG.DB.RocksDB':exit_info({pos_integer(),non_neg_integer(),non_neg_integer()},atom()) -> {'ok',map()} | {'error',atom()} is a subtype of the success typing: 'Elixir.OMG.DB.RocksDB':exit_info(_,atom() | pid() | {atom(),_} | {'via',atom(),_}) -> any()
Type specification 'Elixir.OMG.DB.RocksDB':spent_blknum(utxo_pos_db_t(),atom()) -> {'ok',pos_integer()} | {'error',atom()} is a subtype of the success typing: 'Elixir.OMG.DB.RocksDB':spent_blknum(_,atom() | pid() | {atom(),_} | {'via',atom(),_}) -> any()
Type specification 'Elixir.OMG.DB.RocksDB.Core':decode_value({'ok',binary()} | 'not_found',atom()) -> {'ok',term()} | 'not_found' is a subtype of the success typing: 'Elixir.OMG.DB.RocksDB.Core':decode_value('not_found' | binary() | {'ok',binary()},_) -> 'not_found' | {'ok',_}
Type specification 'Elixir.OMG.DB.RocksDB.Core':decode_values('Elixir.Enumerable':t(),atom()) -> {'ok',[any()]} is a subtype of the success typing: 'Elixir.OMG.DB.RocksDB.Core':decode_values(_,_) -> {'ok',[any()]}
Type specification 'Elixir.OMG.DB.RocksDB.Recorder':update_multiread(atom()) -> integer() is a subtype of the success typing: 'Elixir.OMG.DB.RocksDB.Recorder':update_multiread(atom() | ets:tid()) -> integer()
Type specification 'Elixir.OMG.DB.RocksDB.Recorder':update_read(atom()) -> integer() is a subtype of the success typing: 'Elixir.OMG.DB.RocksDB.Recorder':update_read(atom() | ets:tid()) -> integer()
Type specification 'Elixir.OMG.DB.RocksDB.Recorder':update_write(atom()) -> integer() is a subtype of the success typing: 'Elixir.OMG.DB.RocksDB.Recorder':update_write(atom() | ets:tid()) -> integer()
Type specification 'Elixir.OMG.Eth':contract_transact(address(),address(),binary(),[any()],elixir:keyword()) -> {'ok',hash()} | {'error',any()} is not equal to the success typing: 'Elixir.OMG.Eth':contract_transact(binary() | non_neg_integer(),binary() | non_neg_integer(),binary() | #{'__struct__':='Elixir.ABI.FunctionSelector', 'function':=_, 'types':=[any()], _=>_},[any()],_) -> {'error',atom() | binary() | map()} | {'ok',<<_:256>>}
Type specification 'Elixir.OMG.Eth':get_call_data(binary(),binary(),[atom()],[atom()]) -> map() is a subtype of the success typing: 'Elixir.OMG.Eth':get_call_data(binary() | non_neg_integer(),_,_,_) -> map()
Type specification 'Elixir.OMG.Eth.Encoding':int_from_hex(<<_:16,_:_*8>>) -> non_neg_integer() is a subtype of the success typing: 'Elixir.OMG.Eth.Encoding':int_from_hex(<<_:16,_:_*8>>) -> integer()
Type specification 'Elixir.OMG.Eth.Encoding':to_hex(binary() | non_neg_integer()) -> binary() is not equal to the success typing: 'Elixir.OMG.Eth.Encoding':to_hex(binary() | integer()) -> <<_:16,_:_*8>>
Type specification 'Elixir.OMG.Eth.RootChain':contract_ready(optional_addr_t()) -> 'ok' | {'error','root_chain_contract_not_available' | 'root_chain_authority_is_nil'} is a subtype of the success typing: 'Elixir.OMG.Eth.RootChain':contract_ready(_) -> 'ok' | {'error','root_chain_authority_is_nil' | 'root_chain_contract_not_available'}
Type specification 'Elixir.OMG.Eth.RootChain':get_child_block_interval() -> {'ok',pos_integer()} | 'error' is a subtype of the success typing: 'Elixir.OMG.Eth.RootChain':get_child_block_interval() -> 'error' | {'ok',_}
Type specification 'Elixir.OMG.Eth.RootChain':get_piggybacks(non_neg_integer(),non_neg_integer(),optional_addr_t()) -> {'ok',[in_flight_exit_piggybacked_event()]} is a subtype of the success typing: 'Elixir.OMG.Eth.RootChain':get_piggybacks(_,_,_) -> any()
Type specification 'Elixir.OMG.Eth.RootChain':submit_block(binary(),pos_integer(),pos_integer(),optional_addr_t(),optional_addr_t()) -> {'error',binary() | atom() | map()} | {'ok',binary()} is not equal to the success typing: 'Elixir.OMG.Eth.RootChain':submit_block(_,_,_,'false' | 'nil' | <<_:160>>,'false' | 'nil' | <<_:160>>) -> {'error',atom() | binary() | map()} | {'ok',<<_:256>>}
Type specification 'Elixir.OMG.EthereumClientMonitor':check() -> non_neg_integer() | 'error' is a subtype of the success typing: 'Elixir.OMG.EthereumClientMonitor':check() -> any()
Type specification 'Elixir.OMG.EthereumClientMonitor':raise_clear(module(),boolean(),'error' | non_neg_integer()) -> 'ok' | 'duplicate' is a subtype of the success typing: 'Elixir.OMG.EthereumClientMonitor':raise_clear(_,boolean(),_) -> any()
Type specification 'Elixir.OMG.EthereumEventListener':prepare_child(elixir:keyword()) -> #{'id':=atom(),'start':=tuple()} is not equal to the success typing: 'Elixir.OMG.EthereumEventListener':prepare_child([{atom(),_}]) -> #{'id':=_, 'start':={'Elixir.OMG.EthereumEventListener','start_link',[map(),...]}}
Type specification 'Elixir.OMG.EthereumEventListener':start_link(config()) -> 'Elixir.GenServer':on_start() is a subtype of the success typing: 'Elixir.OMG.EthereumEventListener':start_link(#{'service_name':=atom() | {'global',_} | {'via',atom(),_}, _=>_}) -> 'ignore' | {'error',_} | {'ok',pid()}
Type specification 'Elixir.OMG.EthereumEventListener.Core':add_new_events(t(),[event()]) -> t() is a subtype of the success typing: 'Elixir.OMG.EthereumEventListener.Core':add_new_events(#{'__struct__':='Elixir.OMG.EthereumEventListener.Core', 'cached':=#{'data':=[any()], _=>_}, _=>_},_) -> #{'__struct__':='Elixir.OMG.EthereumEventListener.Core', 'cached':=#{'data':=_, _=>_}, _=>_}
Type specification 'Elixir.OMG.EthereumEventListener.Core':get_events(t(),non_neg_integer()) -> {'ok',[event()],[any()],non_neg_integer(),t()} is not equal to the success typing: 'Elixir.OMG.EthereumEventListener.Core':get_events(#{'__struct__':='Elixir.OMG.EthereumEventListener.Core', 'cached':=#{'data':=_, _=>_}, 'synced_height_update_key':=_, _=>_},_) -> {'ok',[any()],[{_,_,_},...],non_neg_integer(),#{'__struct__':='Elixir.OMG.EthereumEventListener.Core', 'cached':=map(), 'service_name':=atom(), 'synced_height':=_, 'synced_height_update_key':=atom()}}
Type specification 'Elixir.OMG.EthereumEventListener.Core':get_events_range_for_download(t(),'Elixir.OMG.RootChainCoordinator.SyncGuide':t()) -> {'dont_fetch_events',t()} | {'get_events',{non_neg_integer(),non_neg_integer()},t()} is a subtype of the success typing: 'Elixir.OMG.EthereumEventListener.Core':get_events_range_for_download(#{'__struct__':='Elixir.OMG.EthereumEventListener.Core', 'cached':=#{'events_upper_bound':=_, _=>_}, _=>_},#{'__struct__':='Elixir.OMG.RootChainCoordinator.SyncGuide', 'sync_height':=_, _=>_}) -> {'dont_fetch_events',#{'__struct__':='Elixir.OMG.EthereumEventListener.Core', 'cached':=#{'events_upper_bound':=_, _=>_}, _=>_}} | {'get_events',{number(),_},#{'__struct__':='Elixir.OMG.EthereumEventListener.Core', 'cached':=#{'events_upper_bound':=_, 'request_max_size':=number(), _=>_}, _=>_}}
Type specification 'Elixir.OMG.EthereumEventListener.Core':get_height_to_check_in(t()) -> non_neg_integer() is a subtype of the success typing: 'Elixir.OMG.EthereumEventListener.Core':get_height_to_check_in(#{'__struct__':='Elixir.OMG.EthereumEventListener.Core', 'synced_height':=_, _=>_}) -> any()
Type specification 'Elixir.OMG.EthereumEventListener.Core':init(atom(),atom(),non_neg_integer(),non_neg_integer()) -> {t(),non_neg_integer()} | {'error','invalid_init'} is not equal to the success typing: 'Elixir.OMG.EthereumEventListener.Core':init(_,_,_,_) -> {'error' | #{'__struct__':='Elixir.OMG.EthereumEventListener.Core', 'cached':=#{'data':=[], 'events_upper_bound':=non_neg_integer(), 'request_max_size':=pos_integer()}, 'service_name':=atom(), 'synced_height':=non_neg_integer(), 'synced_height_update_key':=atom()},'invalid_init' | non_neg_integer()}
Type specification 'Elixir.OMG.Fees':'covered?'(input_amounts::map(),output_amounts::map(),fees::fee_t()) -> boolean() is a subtype of the success typing: 'Elixir.OMG.Fees':'covered?'(_,_,_) -> boolean()
Type specification 'Elixir.OMG.Fees':for_tx('Elixir.OMG.State.Transaction.Recovered':t(),fee_t()) -> fee_t() is a subtype of the success typing: 'Elixir.OMG.Fees':for_tx(_,_) -> any()
Type specification 'Elixir.OMG.Fees':parse_file_content(binary()) -> {'ok',fee_t()} | {'error',[{'error',atom()}]} is not equal to the success typing: 'Elixir.OMG.Fees':parse_file_content(binary() | maybe_improper_list(binary() | maybe_improper_list(any(),binary() | []) | byte(),binary() | [])) -> {'error',[any(),...]} | {'ok',_}
Type specification 'Elixir.OMG.RootChainCoordinator':check_in(non_neg_integer(),atom()) -> 'ok' is a subtype of the success typing: 'Elixir.OMG.RootChainCoordinator':check_in(_,_) -> any()
Type specification 'Elixir.OMG.RootChainCoordinator':get_ethereum_heights() -> {'ok','Elixir.OMG.RootChainCoordinator.Core':ethereum_heights_result_t()} is a subtype of the success typing: 'Elixir.OMG.RootChainCoordinator':get_ethereum_heights() -> any()
Type specification 'Elixir.OMG.RootChainCoordinator':get_sync_info() -> 'Elixir.OMG.RootChainCoordinator.SyncGuide':t() | 'nosync' is a subtype of the success typing: 'Elixir.OMG.RootChainCoordinator':get_sync_info() -> any()
Type specification 'Elixir.OMG.RootChainCoordinator':start_link('Elixir.OMG.RootChainCoordinator.Core':configs_services()) -> 'Elixir.GenServer':on_start() is a subtype of the success typing: 'Elixir.OMG.RootChainCoordinator':start_link(_) -> 'ignore' | {'error',_} | {'ok',pid()}
Type specification 'Elixir.OMG.RootChainCoordinator.Core':check_in(t(),pid(),pos_integer(),atom()) -> {'ok',t()} | check_in_error_t() is a subtype of the success typing: 'Elixir.OMG.RootChainCoordinator.Core':check_in(atom() | #{'configs_services':=map(), _=>_},_,integer(),_) -> {'error','service_not_allowed'} | {'ok',#{'__struct__':='Elixir.OMG.RootChainCoordinator.Core', 'configs_services':=_, 'services':=map(), _=>_}}
Type specification 'Elixir.OMG.RootChainCoordinator.Core':check_out(t(),pid()) -> {'ok',t()} is a subtype of the success typing: 'Elixir.OMG.RootChainCoordinator.Core':check_out(#{'__struct__':='Elixir.OMG.RootChainCoordinator.Core', 'services':=map(), _=>_},_) -> {'ok',#{'__struct__':='Elixir.OMG.RootChainCoordinator.Core', 'services':=map(), _=>_}}
Type specification 'Elixir.OMG.RootChainCoordinator.Core':get_ethereum_heights(t()) -> ethereum_heights_result_t() is a subtype of the success typing: 'Elixir.OMG.RootChainCoordinator.Core':get_ethereum_heights(#{'__struct__':='Elixir.OMG.RootChainCoordinator.Core', 'root_chain_height':=_, 'services':=_, _=>_}) -> any()
Type specification 'Elixir.OMG.RootChainCoordinator.Core':get_synced_info(t(),atom() | pid()) -> 'Elixir.OMG.RootChainCoordinator.SyncGuide':t() | 'nosync' is a subtype of the success typing: 'Elixir.OMG.RootChainCoordinator.Core':get_synced_info(atom() | #{'services':=_, _=>_},atom() | pid()) -> 'nosync' | #{'__struct__':='Elixir.OMG.RootChainCoordinator.SyncGuide', 'root_chain_height':=_, 'sync_height':=_}
Type specification 'Elixir.OMG.RootChainCoordinator.Core':init(map(),non_neg_integer()) -> t() is not equal to the success typing: 'Elixir.OMG.RootChainCoordinator.Core':init(_,_) -> #{'__struct__':='Elixir.OMG.RootChainCoordinator.Core', 'configs_services':=_, 'root_chain_height':=_, 'services':=#{}}
Type specification 'Elixir.OMG.RootChainCoordinator.Core':update_root_chain_height(t(),pos_integer()) -> {'ok',t()} is a subtype of the success typing: 'Elixir.OMG.RootChainCoordinator.Core':update_root_chain_height(#{'__struct__':='Elixir.OMG.RootChainCoordinator.Core', 'root_chain_height':=_, _=>_},integer()) -> {'ok',#{'__struct__':='Elixir.OMG.RootChainCoordinator.Core', 'root_chain_height':=_, _=>_}}
Type specification 'Elixir.OMG.Signature':'uses_chain_id?'(hash_v()) -> boolean() is a subtype of the success typing: 'Elixir.OMG.Signature':'uses_chain_id?'(_) -> boolean()
Type specification 'Elixir.OMG.Signature':recover_public(keccak_hash(),hash_v(),hash_r(),hash_s(),integer() | 'nil') -> {'ok',public_key()} | {'error','Elixir.String':t()} is not equal to the success typing: 'Elixir.OMG.Signature':recover_public(binary(),integer(),non_neg_integer(),non_neg_integer(),_) -> {'error',binary()} | {'ok',binary()}
Type specification 'Elixir.OMG.State':'utxo_exists?'('Elixir.OMG.Utxo.Position':t()) -> boolean() is a subtype of the success typing: 'Elixir.OMG.State':'utxo_exists?'(_) -> any()
Type specification 'Elixir.OMG.State':close_block(pos_integer()) -> {'ok',['Elixir.OMG.State.Core':db_update()]} is a subtype of the success typing: 'Elixir.OMG.State':close_block(_) -> any()
Type specification 'Elixir.OMG.State':deposit(deposits::['Elixir.OMG.State.Core':deposit()]) -> {'ok',['Elixir.OMG.State.Core':db_update()]} is a subtype of the success typing: 'Elixir.OMG.State':deposit(_) -> any()
Type specification 'Elixir.OMG.State.Transaction.Validator':can_apply_spend(state::'Elixir.OMG.State.Core':t(),tx::'Elixir.OMG.State.Transaction.Recovered':t(),fees::'Elixir.OMG.Fees':fee_t()) -> 'true' | {{'error',exec_error()},'Elixir.OMG.State.Core':t()} is a subtype of the success typing: 'Elixir.OMG.State.Transaction.Validator':can_apply_spend(#{'__struct__':='Elixir.OMG.State.Core', 'tx_index':=_, _=>_},#{'__struct__':='Elixir.OMG.State.Transaction.Recovered', 'inputs'=>[#{'blknum':=non_neg_integer(), 'oindex':=non_neg_integer(), 'txindex':=non_neg_integer()}], 'metadata'=>'nil' | binary(), 'outputs'=>[#{'amount':=non_neg_integer(), 'currency':=<<_:160>>, 'owner':=<<_:160>>}], 'raw_tx'=>#{'__struct__':='Elixir.OMG.State.Transaction', 'inputs':=[map()], 'metadata':='nil' | binary(), 'outputs':=[map()]}, 'signed_tx'=>#{'__struct__':='Elixir.OMG.State.Transaction.Signed', 'raw_tx':=#{'__struct__':='Elixir.OMG.State.Transaction', 'inputs':=[any()], 'metadata':='nil' | binary(), 'outputs':=[any()]}, 'signed_tx_bytes':='nil' | binary(), 'sigs':=[<<_:520>>]}, 'signed_tx_bytes'=>'nil' | binary(), 'sigs'=>[<<_:520>>], 'spenders'=>[<<_:160>>], 'tx_hash'=><<_:256>>},_) -> 'true' | {{'error','amounts_do_not_add_up' | 'fees_not_covered' | 'input_utxo_ahead_of_state' | 'too_many_transactions_in_block' | 'unauthorized_spent' | 'utxo_not_found'},#{'__struct__':='Elixir.OMG.State.Core', 'tx_index':=_, _=>_}}
Type specification 'Elixir.OMG.State':exec(tx::'Elixir.OMG.State.Transaction.Recovered':t(),fees::'Elixir.OMG.Fees':fee_t()) -> {'ok',{'Elixir.OMG.State.Transaction':tx_hash(),pos_integer(),non_neg_integer()}} | {'error',exec_error()} is a subtype of the success typing: 'Elixir.OMG.State':exec(_,_) -> any()
Type specification 'Elixir.OMG.State':exit_utxos(utxos::'Elixir.OMG.State.Core':exiting_utxos_t()) -> {'ok',['Elixir.OMG.State.Core':db_update()],'Elixir.OMG.State.Core':validities_t()} is a subtype of the success typing: 'Elixir.OMG.State':exit_utxos(_) -> any()
Type specification 'Elixir.OMG.State':get_status() -> {non_neg_integer(),boolean()} is a subtype of the success typing: 'Elixir.OMG.State':get_status() -> any()
Type specification 'Elixir.OMG.State.Core':'utxo_exists?'('Elixir.OMG.Utxo.Position':t(),t()) -> boolean() is a subtype of the success typing: 'Elixir.OMG.State.Core':'utxo_exists?'({'utxo_position',_,_,_},#{'__struct__':='Elixir.OMG.State.Core', 'utxos':=map(), _=>_}) -> boolean()
Type specification 'Elixir.OMG.State.Core':db_update_utxos(non_neg_integer(),['Elixir.OMG.State.Transaction.Recovered':t()]) -> [{'put','utxo',{'Elixir.OMG.Utxo.Position':db_t(),'Elixir.OMG.Utxo':t()}} | {'delet','utxo','Elixir.OMG.Utxo.Position':db_t()}] is a subtype of the success typing: 'Elixir.OMG.State.Core':db_update_utxos(non_neg_integer(),[#{'__struct__':='Elixir.OMG.State.Transaction.Recovered', 'signed_tx':=map(), 'spenders':=[any()], 'tx_hash':=<<_:256>>}]) -> maybe_improper_list()
Type specification 'Elixir.OMG.State.Core':deposit(deposits::[deposit()],state::t()) -> {'ok',{[deposit_event()],[db_update()]},new_state::t()} is a subtype of the success typing: 'Elixir.OMG.State.Core':deposit(_,#{'__struct__':='Elixir.OMG.State.Core', 'last_deposit_child_blknum':=_, 'utxos':=map(), _=>_}) -> {'ok',{[any()],[any()]},#{'__struct__':='Elixir.OMG.State.Core', 'last_deposit_child_blknum':=_, 'utxos':=map(), _=>_}}
Type specification 'Elixir.OMG.State.Core':exec(state::t(),tx::'Elixir.OMG.State.Transaction.Recovered':t(),fees::'Elixir.OMG.Fees':fee_t()) -> {'ok',{'Elixir.OMG.State.Transaction':tx_hash(),pos_integer(),non_neg_integer()},t()} | {{'error','Elixir.OMG.State.Transaction.Validator':exec_error()},t()} is not equal to the success typing: 'Elixir.OMG.State.Core':exec(#{'__struct__':='Elixir.OMG.State.Core', 'height':=non_neg_integer(), 'last_deposit_child_blknum':=non_neg_integer(), 'pending_txs':=[#{'__struct__':='Elixir.OMG.State.Transaction.Recovered', 'signed_tx':=map(), 'spenders':=[any()], 'tx_hash':=<<_:256>>}], 'tx_index':=non_neg_integer(), 'utxos':=#{{'utxo_position',non_neg_integer(),non_neg_integer(),non_neg_integer()}=>#{'__struct__':='Elixir.OMG.Utxo', 'amount':=non_neg_integer(), 'creating_txhash':=<<_:256>>, 'currency':=<<_:160>>, 'owner':=<<_:160>>}}},#{'__struct__':='Elixir.OMG.State.Transaction.Recovered', 'signed_tx':=#{'__struct__':='Elixir.OMG.State.Transaction.Signed', 'raw_tx':=#{'__struct__':='Elixir.OMG.State.Transaction', 'inputs':=[any()], 'metadata':='nil' | binary(), 'outputs':=[any()]}, 'signed_tx_bytes':='nil' | binary(), 'sigs':=[<<_:520>>]}, 'spenders':=[<<_:160>>], 'tx_hash':=<<_:256>>},'ignore' | #{<<_:160>>=>non_neg_integer()}) -> {{'error','amounts_do_not_add_up' | 'fees_not_covered' | 'input_utxo_ahead_of_state' | 'too_many_transactions_in_block' | 'unauthorized_spent' | 'utxo_not_found'},#{'__struct__':='Elixir.OMG.State.Core', 'height':=non_neg_integer(), 'last_deposit_child_blknum':=non_neg_integer(), 'pending_txs':=[map()], 'tx_index':=non_neg_integer(), 'utxos':=#{{_,_,_,_}=>map()}}} | {'ok',{<<_:256>>,non_neg_integer(),non_neg_integer()},#{'__struct__':='Elixir.OMG.State.Core', 'height':=non_neg_integer(), 'last_deposit_child_blknum':=non_neg_integer(), 'pending_txs':=[map(),...], 'tx_index':=pos_integer(), 'utxos':=map()}}
Type specification 'Elixir.OMG.State.Core':exit_utxos(exiting_utxos::exiting_utxos_t(),state::t()) -> {'ok',{[db_update()],validities_t()},new_state::t()} is a subtype of the success typing: 'Elixir.OMG.State.Core':exit_utxos(_,#{'__struct__':='Elixir.OMG.State.Core', 'utxos':=map(), _=>_}) -> {'ok',{[any()],{_,_}},#{'__struct__':='Elixir.OMG.State.Core', 'utxos':=map(), _=>_}}
Type specification 'Elixir.OMG.State.Core':extract_initial_state(utxos_query_result::[[{'Elixir.OMG.DB':utxo_pos_db_t(),'Elixir.OMG.Utxo':t()}]],height_query_result::non_neg_integer() | 'not_found',last_deposit_child_blknum_query_result::non_neg_integer() | 'not_found',child_block_interval::pos_integer()) -> {'ok',t()} | {'error','last_deposit_not_found' | 'top_block_number_not_found'} is not equal to the success typing: 'Elixir.OMG.State.Core':extract_initial_state(_,_,_,_) -> {'error','last_deposit_not_found' | 'top_block_number_not_found'} | {'ok',#{'__struct__':='Elixir.OMG.State.Core', 'height':=integer(), 'last_deposit_child_blknum':=integer(), 'pending_txs':=[], 'tx_index':=0, 'utxos':=map()}}
Type specification 'Elixir.OMG.State.Core':form_block(pos_integer(),pos_integer() | 'nil',state::t()) -> {'ok',{'Elixir.OMG.Block':t(),[tx_event()],[db_update()]},new_state::t()} is not equal to the success typing: 'Elixir.OMG.State.Core':form_block(number(),_,#{'__struct__':='Elixir.OMG.State.Core', 'height':=non_neg_integer(), 'pending_txs':=_, 'tx_index':=_, _=>_}) -> {'ok',{map(),[any()],[any(),...]},#{'__struct__':='Elixir.OMG.State.Core', 'height':=number(), 'pending_txs':=[], 'tx_index':=0, _=>_}}
Type specification 'Elixir.OMG.State.Core':get_status(t()) -> {current_block_height::non_neg_integer(),is_block_beginning::boolean()} is a subtype of the success typing: 'Elixir.OMG.State.Core':get_status(#{'__struct__':='Elixir.OMG.State.Core', 'height':=_, 'pending_txs':=_, 'tx_index':=_, _=>_}) -> {_,boolean()}
Type specification 'Elixir.OMG.State.Core':standard_exitable_utxos([{'Elixir.OMG.DB':utxo_pos_db_t(),'Elixir.OMG.Utxo':t()}],'Elixir.OMG.Crypto':address_t()) -> [exitable_utxos()] is a subtype of the success typing: 'Elixir.OMG.State.Core':standard_exitable_utxos(_,_) -> [any()]
Type specification 'Elixir.OMG.State.Transaction':decode(tx_bytes()) -> {'ok',t()} | {'error',decode_error()} is a subtype of the success typing: 'Elixir.OMG.State.Transaction':decode(_) -> {'error',_} | {'ok',#{'__struct__':='Elixir.OMG.State.Transaction', 'inputs':=_, 'metadata':='nil' | binary(), 'outputs':=_}}
Type specification 'Elixir.OMG.State.Transaction':encode(t()) -> tx_bytes() is a subtype of the success typing: 'Elixir.OMG.State.Transaction':encode(#{'__struct__':='Elixir.OMG.State.Transaction', 'inputs':=[any()], 'metadata':='nil' | binary(), 'outputs':=[any()], _=>_}) -> binary()
Type specification 'Elixir.OMG.State.Transaction':get_inputs(any_flavor_t()) -> [input()] is a subtype of the success typing: 'Elixir.OMG.State.Transaction':get_inputs(#{'__struct__':='Elixir.OMG.State.Transaction' | 'Elixir.OMG.State.Transaction.Recovered' | 'Elixir.OMG.State.Transaction.Signed', _=>_}) -> [any()]
Type specification 'Elixir.OMG.State.Transaction':get_outputs(any_flavor_t()) -> [output()] is a subtype of the success typing: 'Elixir.OMG.State.Transaction':get_outputs(#{'__struct__':='Elixir.OMG.State.Transaction' | 'Elixir.OMG.State.Transaction.Recovered' | 'Elixir.OMG.State.Transaction.Signed', _=>_}) -> [any()]
Type specification 'Elixir.OMG.State.Transaction':hash(t()) -> tx_hash() is a subtype of the success typing: 'Elixir.OMG.State.Transaction':hash(#{'__struct__':='Elixir.OMG.State.Transaction', 'inputs':=[#{'blknum':=non_neg_integer(), 'oindex':=non_neg_integer(), 'txindex':=non_neg_integer()}], 'metadata':='nil' | binary(), 'outputs':=[#{'amount':=non_neg_integer(), 'currency':=<<_:160>>, 'owner':=<<_:160>>}]}) -> binary()
Type specification 'Elixir.OMG.State.Transaction':new([{pos_integer(),pos_integer(),0 | 1}],[{'Elixir.OMG.Crypto':address_t(),currency(),pos_integer()}],metadata()) -> t() is a subtype of the success typing: 'Elixir.OMG.State.Transaction':new([any()],[any()],'nil' | binary()) -> #{'__struct__':='Elixir.OMG.State.Transaction', 'inputs':=[any()], 'metadata':='nil' | binary(), 'outputs':=[any()]}
Type specification 'Elixir.OMG.State.Transaction':parse_address(<<>> | 'Elixir.OMG.Crypto':address_t()) -> {'ok','Elixir.OMG.Crypto':address_t()} | {'error','malformed_address'} is a subtype of the success typing: 'Elixir.OMG.State.Transaction':parse_address(_) -> {'error','malformed_address'} | {'ok',<<_:160>>}
Type specification 'Elixir.OMG.State.Transaction':raw_txbytes(any_flavor_t()) -> binary() is a subtype of the success typing: 'Elixir.OMG.State.Transaction':raw_txbytes(#{'__struct__':='Elixir.OMG.State.Transaction' | 'Elixir.OMG.State.Transaction.Recovered' | 'Elixir.OMG.State.Transaction.Signed', _=>_}) -> binary()
Type specification 'Elixir.OMG.State.Transaction':raw_txhash(any_flavor_t()) -> binary() is not equal to the success typing: 'Elixir.OMG.State.Transaction':raw_txhash(#{'__struct__':='Elixir.OMG.State.Transaction' | 'Elixir.OMG.State.Transaction.Recovered' | 'Elixir.OMG.State.Transaction.Signed', _=>_}) -> <<_:256>>
Type specification 'Elixir.OMG.State.Transaction.Recovered':'recover_from!'(binary()) -> 'Elixir.OMG.State.Transaction.Recovered':t() is a subtype of the success typing: 'Elixir.OMG.State.Transaction.Recovered':'recover_from!'(binary()) -> #{'__struct__':='Elixir.OMG.State.Transaction.Recovered', 'signed_tx':=#{'__struct__':='Elixir.OMG.State.Transaction.Signed', 'raw_tx':=#{'__struct__':='Elixir.OMG.State.Transaction', 'inputs':=[any()], 'metadata':='nil' | binary(), 'outputs':=[any()]}, 'signed_tx_bytes':='nil' | binary(), 'sigs':=[<<_:520>>]}, 'spenders':=[<<_:160>>], 'tx_hash':=<<_:256>>}
Type specification 'Elixir.OMG.State.Transaction.Recovered':all_spenders_authorized(t(),[any()]) -> 'ok' | {'error','unauthorized_spent'} is a subtype of the success typing: 'Elixir.OMG.State.Transaction.Recovered':all_spenders_authorized(#{'__struct__':='Elixir.OMG.State.Transaction.Recovered', 'spenders':=_, _=>_},_) -> 'ok' | {'error','unauthorized_spent'}
Type specification 'Elixir.OMG.State.Transaction.Recovered':recover_from_struct('Elixir.OMG.State.Transaction.Signed':t()) -> {'ok',t()} | {'error',recover_tx_error()} is a subtype of the success typing: 'Elixir.OMG.State.Transaction.Recovered':recover_from_struct(#{'__struct__':='Elixir.OMG.State.Transaction.Signed', 'raw_tx':=#{'__struct__':='Elixir.OMG.State.Transaction', 'inputs':=[map()], 'metadata':='nil' | binary(), 'outputs':=[map()]}, 'signed_tx_bytes':='nil' | binary(), 'sigs':=[<<_:520>>]}) -> {'error',atom()} | {'ok',#{'__struct__':='Elixir.OMG.State.Transaction.Recovered', 'signed_tx':=#{'__struct__':='Elixir.OMG.State.Transaction.Signed', 'raw_tx':=map(), 'signed_tx_bytes':='nil' | binary(), 'sigs':=[any()]}, 'spenders':=[<<_:160>>], 'tx_hash':=<<_:256>>}}
Type specification 'Elixir.OMG.State.Transaction.Signed':decode(tx_bytes()) -> {'ok',t()} | {'error',atom()} is a subtype of the success typing: 'Elixir.OMG.State.Transaction.Signed':decode(_) -> {'error',_} | {'ok',#{'__struct__':='Elixir.OMG.State.Transaction.Signed', 'raw_tx':=#{'__struct__':='Elixir.OMG.State.Transaction', 'inputs':=_, 'metadata':='nil' | binary(), 'outputs':=_}, 'signed_tx_bytes':=_, 'sigs':=_}}
Type specification 'Elixir.OMG.State.Transaction.Signed':encode(t()) -> tx_bytes() is a subtype of the success typing: 'Elixir.OMG.State.Transaction.Signed':encode(#{'__struct__':='Elixir.OMG.State.Transaction.Signed', 'raw_tx':=#{'__struct__':='Elixir.OMG.State.Transaction', 'inputs':=[any()], 'metadata':='nil' | binary(), 'outputs':=[any()], _=>_}, 'sigs':=_, _=>_}) -> binary()
Type specification 'Elixir.OMG.State.Transaction.Signed':get_spenders(t()) -> {'ok',['Elixir.OMG.Crypto':address_t()]} | {'error',atom()} is a subtype of the success typing: 'Elixir.OMG.State.Transaction.Signed':get_spenders(#{'__struct__':='Elixir.OMG.State.Transaction.Signed', 'raw_tx':=#{'__struct__':='Elixir.OMG.State.Transaction', 'inputs':=[map()], 'metadata':='nil' | binary(), 'outputs':=[map()]}, 'sigs':=_, _=>_}) -> any()
Type specification 'Elixir.OMG.TypedDataHash':hash_struct('Elixir.OMG.State.Transaction':t(),'Elixir.OMG.Crypto':domain_separator_t()) -> 'Elixir.OMG.Crypto':hash_t() is a subtype of the success typing: 'Elixir.OMG.TypedDataHash':hash_struct(#{'__struct__':='Elixir.OMG.State.Transaction', 'inputs':=[#{'blknum':=non_neg_integer(), 'oindex':=non_neg_integer(), 'txindex':=non_neg_integer()}], 'metadata':='nil' | binary(), 'outputs':=[#{'amount':=non_neg_integer(), 'currency':=<<_:160>>, 'owner':=<<_:160>>}]},'false' | 'nil' | binary()) -> binary()
Type specification 'Elixir.OMG.TypedDataHash':hash_transaction('Elixir.OMG.State.Transaction':t()) -> 'Elixir.OMG.Crypto':hash_t() is a subtype of the success typing: 'Elixir.OMG.TypedDataHash':hash_transaction(#{'__struct__':='Elixir.OMG.State.Transaction' | 'Elixir.OMG.State.Transaction.Recovered' | 'Elixir.OMG.State.Transaction.Signed', 'metadata':='nil' | binary(), 'inputs'=>[#{'blknum':=non_neg_integer(), 'oindex':=non_neg_integer(), 'txindex':=non_neg_integer()}], 'outputs'=>[#{'amount':=non_neg_integer(), 'currency':=<<_:160>>, 'owner':=<<_:160>>}], 'raw_tx'=>#{'__struct__':='Elixir.OMG.State.Transaction', 'inputs':=[map()], 'metadata':='nil' | binary(), 'outputs':=[map()]}, 'signed_tx'=>#{'__struct__':='Elixir.OMG.State.Transaction.Signed', 'raw_tx':=#{'__struct__':='Elixir.OMG.State.Transaction', 'inputs':=[any()], 'metadata':='nil' | binary(), 'outputs':=[any()]}, 'signed_tx_bytes':='nil' | binary(), 'sigs':=[<<_:520>>]}, 'signed_tx_bytes'=>'nil' | binary()
Type specification 'Elixir.OMG.TypedDataHash.Tools':domain_separator(binary(),binary(),'Elixir.OMG.Crypto':address_t(),'Elixir.OMG.Crypto':hash_t()) -> 'Elixir.OMG.Crypto':hash_t() is a subtype of the success typing: 'Elixir.OMG.TypedDataHash.Tools':domain_separator(binary() | maybe_improper_list(binary() | maybe_improper_list(any(),binary() | []) | byte(),binary() | []),binary() | maybe_improper_list(binary() | maybe_improper_list(any(),binary() | []) | byte(),binary() | []),_,_) -> binary()
Type specification 'Elixir.OMG.TypedDataHash.Tools':hash_input('Elixir.OMG.Utxo.Position':t()) -> 'Elixir.OMG.Crypto':hash_t() is a subtype of the success typing: 'Elixir.OMG.TypedDataHash.Tools':hash_input({'utxo_position',_,_,_}) -> binary()
Type specification 'Elixir.OMG.TypedDataHash.Tools':hash_output('Elixir.OMG.State.Transaction':output()) -> 'Elixir.OMG.Crypto':hash_t() is a subtype of the success typing: 'Elixir.OMG.TypedDataHash.Tools':hash_output(#{'amount':=_, 'currency':=_, 'owner':=_, _=>_}) -> binary()
Type specification 'Elixir.OMG.TypedDataHash.Tools':hash_transaction(['Elixir.OMG.Utxo.Position':t()],['Elixir.OMG.State.Transaction':output()],'Elixir.OMG.State.Transaction':metadata(),'Elixir.OMG.Crypto':hash_t(),'Elixir.OMG.Crypto':hash_t()) -> 'Elixir.OMG.Crypto':hash_t() is a subtype of the success typing: 'Elixir.OMG.TypedDataHash.Tools':hash_transaction(_,_,_,_,_) -> binary()
Type specification 'Elixir.OMG.Utils.HttpRPC.Encoding':from_hex(<<_:16,_:_*8>>) -> {'ok',binary()} | {'error','invalid_hex'} is a subtype of the success typing: 'Elixir.OMG.Utils.HttpRPC.Encoding':from_hex(_) -> {'error','invalid_hex'} | {'ok',binary()}
Type specification 'Elixir.OMG.Utils.HttpRPC.Error':serialize(atom() | 'Elixir.String':t(),'Elixir.String':t() | 'nil',map() | 'nil') -> map() is not equal to the success typing: 'Elixir.OMG.Utils.HttpRPC.Error':serialize(_,_,_) -> #{'data':=map(), 'success':=boolean(), 'version':=<<_:24>>}
Type specification 'Elixir.OMG.Utils.HttpRPC.Response':serialize(any()) -> response_t() is not equal to the success typing: 'Elixir.OMG.Utils.HttpRPC.Response':serialize(_) -> #{'data':=_, 'success':=boolean(), 'version':=<<_:24>>}
Type specification 'Elixir.OMG.Utils.HttpRPC.Validator.Base':expect(map(),atom() | binary(),atom() | [any()]) -> {'ok',any()} | validation_error_t() is a subtype of the success typing: 'Elixir.OMG.Utils.HttpRPC.Validator.Base':expect(map(),_,_) -> {'error',{'validation_error',binary(),_}} | {'ok',_}
Type specification 'Elixir.OMG.Utils.HttpRPC.Validator.Base':greater({any(),[any()]},integer()) -> {any(),[any()]} is a subtype of the success typing: 'Elixir.OMG.Utils.HttpRPC.Validator.Base':greater({_,maybe_improper_list()},_) -> {_,maybe_improper_list()}
Type specification 'Elixir.OMG.Utils.HttpRPC.Validator.Base':hex({any(),[any()]}) -> {any(),[any()]} is a subtype of the success typing: 'Elixir.OMG.Utils.HttpRPC.Validator.Base':hex({_,maybe_improper_list()}) -> {_,maybe_improper_list()}
Type specification 'Elixir.OMG.Utils.HttpRPC.Validator.Base':integer({any(),[any()]}) -> {any(),[any()]} is a subtype of the success typing: 'Elixir.OMG.Utils.HttpRPC.Validator.Base':integer({_,maybe_improper_list()}) -> {_,maybe_improper_list()}
Type specification 'Elixir.OMG.Utils.HttpRPC.Validator.Base':length({any(),[any()]},non_neg_integer()) -> {any(),[any()]} is a subtype of the success typing: 'Elixir.OMG.Utils.HttpRPC.Validator.Base':length({_,maybe_improper_list()},_) -> {_,maybe_improper_list()}
Type specification 'Elixir.OMG.Utils.HttpRPC.Validator.Base':list({any(),[any()]}) -> {any(),[any()]} is a subtype of the success typing: 'Elixir.OMG.Utils.HttpRPC.Validator.Base':list({_,_}) -> {_,maybe_improper_list()}
Type specification 'Elixir.OMG.Utils.HttpRPC.Validator.Base':optional({any(),[any()]}) -> {any(),[any()]} is a subtype of the success typing: 'Elixir.OMG.Utils.HttpRPC.Validator.Base':optional(_) -> any()
Type specification 'Elixir.OMG.Utxo.Position':'decode!'(number()) -> t() is a supertype of the success typing: 'Elixir.OMG.Utxo.Position':'decode!'(number()) -> {'utxo_position',non_neg_integer(),non_neg_integer(),char()}
Type specification 'Elixir.OMG.Utxo.Position':decode(number()) -> {'ok',t()} | {'error','encoded_utxo_position_too_low'} is a supertype of the success typing: 'Elixir.OMG.Utxo.Position':decode(number()) -> {'error','encoded_utxo_position_too_low'} | {'ok',{'utxo_position',non_neg_integer(),non_neg_integer(),char()}}
Type specification 'Elixir.OMG.Utxo.Position':get_position(pos_integer()) -> {non_neg_integer(),non_neg_integer(),non_neg_integer()} is a supertype of the success typing: 'Elixir.OMG.Utxo.Position':get_position(pos_integer()) -> {non_neg_integer(),non_neg_integer(),char()}
Type specification 'Elixir.OMG.Watcher.API.Account':get_utxos('Elixir.OMG.Crypto':address_t()) -> [#{'__struct__':='Elixir.OMG.Watcher.DB.TxOutput','__meta__':=term(),'amount':=term(),'blknum':=term(),'creating_deposit':=term(),'creating_transaction':=term(),'creating_txhash':=term(),'currency':=term(),'deposit':=term(),'exit':=term(),'oindex':=term(),'owner':=term(),'proof':=term(),'spending_exit':=term(),'spending_transaction':=term(),'spending_tx_oindex':=term(),'spending_txhash':=term(),'txindex':=term()}] is a subtype of the success typing: 'Elixir.OMG.Watcher.API.Account':get_utxos(_) -> any()
Type specification 'Elixir.OMG.Watcher.API.InFlightExit':get_in_flight_exit(binary()) -> {'ok',in_flight_exit()} | {'error',atom()} is a subtype of the success typing: 'Elixir.OMG.Watcher.API.InFlightExit':get_in_flight_exit(_) -> any()
Type specification 'Elixir.OMG.Watcher.API.Status':get_status() -> {'ok',t()} is a subtype of the success typing: 'Elixir.OMG.Watcher.API.Status':get_status() -> any()
Type specification 'Elixir.OMG.Watcher.API.Transaction':create('Elixir.OMG.Watcher.UtxoSelection':order_t()) -> 'Elixir.OMG.Watcher.UtxoSelection':advice_t() is a subtype of the success typing: 'Elixir.OMG.Watcher.API.Transaction':create(_) -> any()
Type specification 'Elixir.OMG.Watcher.API.Transaction':get(binary()) -> {'ok',#{'__struct__':='Elixir.OMG.Watcher.DB.Transaction','__meta__':=term(),'blknum':=term(),'block':=term(),'inputs':=term(),'metadata':=term(),'outputs':=term(),'sent_at':=term(),'txbytes':=term(),'txhash':=term(),'txindex':=term()}} | {'error','transaction_not_found'} is a subtype of the success typing: 'Elixir.OMG.Watcher.API.Transaction':get(_) -> any()
Type specification 'Elixir.OMG.Watcher.API.Transaction':get_transactions('Elixir.Keyword':t()) -> [#{'__struct__':='Elixir.OMG.Watcher.DB.Transaction','__meta__':=term(),'blknum':=term(),'block':=term(),'inputs':=term(),'metadata':=term(),'outputs':=term(),'sent_at':=term(),'txbytes':=term(),'txhash':=term(),'txindex':=term()}] is a subtype of the success typing: 'Elixir.OMG.Watcher.API.Transaction':get_transactions(_) -> any()
Type specification 'Elixir.OMG.Watcher.API.Transaction':submit(binary()) -> 'Elixir.OMG.Watcher.HttpRPC.Client':response_t() is a subtype of the success typing: 'Elixir.OMG.Watcher.API.Transaction':submit(_) -> any()
Type specification 'Elixir.OMG.Watcher.API.Utxo':compose_utxo_exit('Elixir.OMG.Utxo.Position':t()) -> {'ok','Elixir.OMG.Watcher.DB.TxOutput':exit_t()} | {'error','utxo_not_found'} is a subtype of the success typing: 'Elixir.OMG.Watcher.API.Utxo':compose_utxo_exit(_) -> any()
Type specification 'Elixir.OMG.Watcher.API.Utxo':create_challenge('Elixir.OMG.Utxo.Position':t()) -> {'ok','Elixir.OMG.Watcher.ExitProcessor.StandardExitChallenge':t()} | {'error','utxo_not_spent'} | {'error','exit_not_found'} is a subtype of the success typing: 'Elixir.OMG.Watcher.API.Utxo':create_challenge(_) -> any()
Type specification 'Elixir.OMG.Watcher.BlockGetter':get_events() -> {'ok','Elixir.OMG.Watcher.BlockGetter.Core':chain_ok_response_t()} is a subtype of the success typing: 'Elixir.OMG.Watcher.BlockGetter':get_events() -> {'ok',{'error',[map()]} | {'ok',[map()]}}
Type specification 'Elixir.OMG.Watcher.BlockGetter':handle_info('producer' | {reference(),{'downloaded_block',{'ok',map()}}} | {reference(),{'downloaded_block',{'error','Elixir.OMG.Watcher.BlockGetter.Core':block_error()}}} | {'DOWN',reference(),'process',pid(),'normal'},'Elixir.OMG.Watcher.BlockGetter.Core':t()) -> {'noreply','Elixir.OMG.Watcher.BlockGetter.Core':t()} | {'stop','normal','Elixir.OMG.Watcher.BlockGetter.Core':t()} is a subtype of the success typing: 'Elixir.OMG.Watcher.BlockGetter':handle_info('producer' | 'sync' | {_,{'downloaded_block',_}} | {'DOWN',_,'process',_,'normal'},_) -> any()
Type specification 'Elixir.OMG.Watcher.BlockGetter.Core':apply_block(t(),'Elixir.OMG.Watcher.BlockGetter.BlockApplication':t()) -> {t(),non_neg_integer(),[any()]} is not equal to the success typing: 'Elixir.OMG.Watcher.BlockGetter.Core':apply_block(#{'__struct__':='Elixir.OMG.Watcher.BlockGetter.Core', 'synced_height':=_, _=>_},#{'__struct__':='Elixir.OMG.Watcher.BlockGetter.BlockApplication', 'eth_height':=_, 'eth_height_done':=_, 'number':=_, _=>_}) -> {#{'__struct__':='Elixir.OMG.Watcher.BlockGetter.Core', 'synced_height':=_, _=>_},_,[{'put','last_block_getter_eth_height',_}]}
Type specification 'Elixir.OMG.Watcher.BlockGetter.Core':chain_ok(t()) -> chain_ok_response_t() is a subtype of the success typing: 'Elixir.OMG.Watcher.BlockGetter.Core':chain_ok(#{'__struct__':='Elixir.OMG.Watcher.BlockGetter.Core', 'chain_status':=_, 'events':=_, _=>_}) -> {_,_}
Type specification 'Elixir.OMG.Watcher.BlockGetter.Core':consider_exits(t(),'Elixir.OMG.Watcher.ExitProcessor.Core':check_validity_result_t()) -> t() is a subtype of the success typing: 'Elixir.OMG.Watcher.BlockGetter.Core':consider_exits(#{'__struct__':='Elixir.OMG.Watcher.BlockGetter.Core', _=>_},{'ok' | {'error','unchallenged_exit'},_}) -> map()
Type specification 'Elixir.OMG.Watcher.BlockGetter.Core':ensure_block_imported_once('Elixir.OMG.Watcher.BlockGetter.BlockApplication':t(),t()) -> ['Elixir.OMG.Watcher.DB.Transaction':mined_block()] is a subtype of the success typing: 'Elixir.OMG.Watcher.BlockGetter.Core':ensure_block_imported_once(#{'__struct__':='Elixir.OMG.Watcher.BlockGetter.BlockApplication', 'number':=_, _=>_},#{'__struct__':='Elixir.OMG.Watcher.BlockGetter.Core', 'last_block_persisted_from_prev_run':=_, _=>_}) -> [#{'blkhash':=<<_:256>>, 'blknum':=pos_integer(), 'eth_height':=pos_integer(), 'timestamp':=pos_integer(), 'transactions':=[map()]}]
Type specification 'Elixir.OMG.Watcher.BlockGetter.Core':get_blocks_to_apply(t(),[any()],non_neg_integer()) -> {['Elixir.OMG.Watcher.BlockGetter.BlockApplication':t()],non_neg_integer(),[any()],t()} is not equal to the success typing: 'Elixir.OMG.Watcher.BlockGetter.Core':get_blocks_to_apply(#{'__struct__':='Elixir.OMG.Watcher.BlockGetter.Core', 'last_applied_block':=_, 'synced_height':=_, _=>_},_,_) -> {[any()],_,[{_,_,_}],#{'__struct__':='Elixir.OMG.Watcher.BlockGetter.Core', 'last_applied_block':=_, 'synced_height':=_, _=>_}}
Type specification 'Elixir.OMG.Watcher.BlockGetter.Core':get_eth_range_for_block_submitted_events(t(),non_neg_integer()) -> {pos_integer(),pos_integer()} is not equal to the success typing: 'Elixir.OMG.Watcher.BlockGetter.Core':get_eth_range_for_block_submitted_events(#{'__struct__':='Elixir.OMG.Watcher.BlockGetter.Core', 'config':=atom() | #{'block_getter_reorg_margin':=number(), _=>_}, 'synced_height':=number(), _=>_},_) -> {_,_}
Type specification 'Elixir.OMG.Watcher.BlockGetter.Core':get_numbers_of_blocks_to_download(#{'__struct__':='Elixir.OMG.Watcher.BlockGetter.Core','chain_status':=term(),'config':=term(),'events':=term(),'last_applied_block':=term(),'last_block_persisted_from_prev_run':=term(),'num_of_highest_block_being_downloaded':=term(),'number_of_blocks_being_downloaded':=term(),'potential_block_withholdings':=term(),'synced_height':=term(),'unapplied_blocks':=term()},non_neg_integer()) -> {#{'__struct__':='Elixir.OMG.Watcher.BlockGetter.Core','chain_status':=term(),'config':=term(),'events':=term(),'last_applied_block':=term(),'last_block_persisted_from_prev_run':=term(),'num_of_highest_block_being_downloaded':=term(),'number_of_blocks_being_downloaded':=term(),'potential_block_withholdings':=term(),'synced_height':=term(),'unapplied_blocks':=term()},[non_neg_integer()]} is a subtype of the success typing: 'Elixir.OMG.Watcher.BlockGetter.Core':get_numbers_of_bl
Type specification 'Elixir.OMG.Watcher.BlockGetter.Core':init(non_neg_integer(),pos_integer(),non_neg_integer(),non_neg_integer(),non_neg_integer(),boolean(),'Elixir.OMG.Watcher.ExitProcessor.Core':check_validity_result_t(),'Elixir.Keyword':t()) -> {'ok',#{'__struct__':='Elixir.OMG.Watcher.BlockGetter.Core','chain_status':=term(),'config':=term(),'events':=term(),'last_applied_block':=term(),'last_block_persisted_from_prev_run':=term(),'num_of_highest_block_being_downloaded':=term(),'number_of_blocks_being_downloaded':=term(),'potential_block_withholdings':=term(),'synced_height':=term(),'unapplied_blocks':=term()}} | {'error',init_error()} is a subtype of the success typing: 'Elixir.OMG.Watcher.BlockGetter.Core':init(_,_,_,_,_,_,_,_) -> any()
Type specification 'Elixir.OMG.Watcher.BlockGetter.Core':to_mined_block('Elixir.OMG.Watcher.BlockGetter.BlockApplication':t()) -> 'Elixir.OMG.Watcher.DB.Transaction':mined_block() is a subtype of the success typing: 'Elixir.OMG.Watcher.BlockGetter.Core':to_mined_block(#{'__struct__':='Elixir.OMG.Watcher.BlockGetter.BlockApplication', 'eth_height':=_, 'hash':=_, 'number':=_, 'timestamp':=_, 'transactions':=_, _=>_}) -> #{'blkhash':=_, 'blknum':=_, 'eth_height':=_, 'timestamp':=_, 'transactions':=_}
Type specification 'Elixir.OMG.Watcher.BlockGetter.Core':validate_download_response({'ok',map()} | {'error',block_error()},binary(),pos_integer(),pos_integer(),pos_integer()) -> validate_download_response_result_t() is not equal to the success typing: 'Elixir.OMG.Watcher.BlockGetter.Core':validate_download_response({'error',_} | {'ok',#{'hash':=_, 'number':=_, 'transactions':=_, _=>_}},_,_,_,_) -> {'error',{_,_,_}} | {'ok',#{'__struct__':=atom(), atom()=>_}}
Type specification 'Elixir.OMG.Watcher.BlockGetter.Core':validate_executions([{'Elixir.OMG.State.Transaction':tx_hash(),pos_integer(),pos_integer()}],map(),t()) -> {'ok',t()} | {{'error',{'tx_execution',any()}},t()} is not equal to the success typing: 'Elixir.OMG.Watcher.BlockGetter.Core':validate_executions(_,#{'hash':=_, 'number':=_, _=>_},_) -> {'ok' | {'error',{'tx_execution',_}},_}
Type specification 'Elixir.OMG.Watcher.BlockGetter.Status':get_events() -> {'ok','Elixir.OMG.Watcher.BlockGetter.Core':chain_ok_response_t()} is a subtype of the success typing: 'Elixir.OMG.Watcher.BlockGetter.Status':get_events() -> any()
Type specification 'Elixir.OMG.Watcher.BlockGetter.Status':update('Elixir.OMG.Watcher.BlockGetter.Core':chain_ok_response_t()) -> 'ok' is a subtype of the success typing: 'Elixir.OMG.Watcher.BlockGetter.Status':update(_) -> 'ok'
Type specification 'Elixir.OMG.Watcher.DB.EthEvent':'insert_deposits!'(['Elixir.OMG.State.Core':deposit()]) -> 'ok' is a subtype of the success typing: 'Elixir.OMG.Watcher.DB.EthEvent':'insert_deposits!'(_) -> 'ok'
Type specification 'Elixir.OMG.Watcher.DB.EthEvent':'insert_exits!'([non_neg_integer()]) -> 'ok' is a subtype of the success typing: 'Elixir.OMG.Watcher.DB.EthEvent':'insert_exits!'(_) -> 'ok'
Type specification 'Elixir.OMG.Watcher.DB.EthEvent':generate_unique_key('Elixir.OMG.Utxo.Position':t(),'deposit' | 'exit') -> 'Elixir.OMG.Crypto':hash_t() is a subtype of the success typing: 'Elixir.OMG.Watcher.DB.EthEvent':generate_unique_key({'utxo_position',non_neg_integer(),non_neg_integer(),non_neg_integer()},_) -> binary()
Type specification 'Elixir.OMG.Watcher.DB.EthEvent':utxo_pos_from_exit_event(#{'call_data':=#{'utxo_pos':=pos_integer()}}) -> 'Elixir.OMG.Utxo.Position':t() is a subtype of the success typing: 'Elixir.OMG.Watcher.DB.EthEvent':utxo_pos_from_exit_event(#{'call_data':=#{'utxo_pos':=number(), _=>_}, _=>_}) -> {'utxo_position',non_neg_integer(),non_neg_integer(),non_neg_integer()}
Type specification 'Elixir.OMG.Watcher.DB.EthEvent':utxo_pos_from_exit_event(#{'call_data':=#{'utxo_pos':=pos_integer()}}) -> 'Elixir.OMG.Utxo.Position':t() is not equal to the success typing: 'Elixir.OMG.Watcher.DB.EthEvent':utxo_pos_from_exit_event(#{'call_data':=#{'utxo_pos':=number(), _=>_}, _=>_}) -> {'utxo_position',non_neg_integer(),non_neg_integer(),char()}
Type specification 'Elixir.OMG.Watcher.DB.Repo':insert_all_chunked(schema_or_source::binary() | atom() | 'Elixir.Ecto.Schema':t(),entries::[map() | 'Elixir.Keyword':t()],opts::'Elixir.Keyword':t()) -> 'ok' is a subtype of the success typing: 'Elixir.OMG.Watcher.DB.Repo':insert_all_chunked(_,maybe_improper_list(),_) -> 'ok'
Type specification 'Elixir.OMG.Watcher.DB.Repo':rollback(term()) -> no_return() is a subtype of the success typing: 'Elixir.OMG.Watcher.DB.Repo':rollback(_) -> any()
Type specification 'Elixir.OMG.Watcher.DB.Transaction':create(pos_integer(),integer(),binary(),binary(),'Elixir.OMG.State.Transaction':metadata()) -> map() is not equal to the success typing: 'Elixir.OMG.Watcher.DB.Transaction':create(_,_,<<_:256>>,_,_) -> #{'blknum':=_, 'metadata':=_, 'txbytes':=_, 'txhash':=<<_:256>>, 'txindex':=_}
Type specification 'Elixir.OMG.Watcher.DB.Transaction':get_by_filters('Elixir.Keyword':t()) -> [#{'__struct__':='Elixir.OMG.Watcher.DB.Transaction','__meta__':=term(),'blknum':=term(),'block':=term(),'inputs':=term(),'metadata':=term(),'outputs':=term(),'sent_at':=term(),'txbytes':=term(),'txhash':=term(),'txindex':=term()}] is a subtype of the success typing: 'Elixir.OMG.Watcher.DB.Transaction':get_by_filters([{atom(),_}]) -> any()
Type specification 'Elixir.OMG.Watcher.DB.Transaction':process('Elixir.OMG.State.Transaction.Recovered':t(),pos_integer(),integer(),[any()]) -> [[any()]] is not equal to the success typing: 'Elixir.OMG.Watcher.DB.Transaction':process(#{'__struct__':='Elixir.OMG.State.Transaction.Recovered', 'signed_tx':=#{'__struct__':='Elixir.OMG.State.Transaction.Signed', 'raw_tx':=#{'__struct__':='Elixir.OMG.State.Transaction', 'inputs':=[any()], 'metadata':='nil' | binary(), 'outputs':=[any()]}, 'signed_tx_bytes':=binary(), 'inputs'=>[map()], 'metadata'=>'nil' | binary(), 'outputs'=>[map()], 'signed_tx'=>#{'__struct__':='Elixir.OMG.State.Transaction.Signed', 'raw_tx':=map(), 'signed_tx_bytes':='nil' | binary(), 'sigs':=[any()]}, 'sigs'=>[<<_:520>>], 'spenders'=>[<<_:160>>], 'tx_hash'=><<_:256>>}, _=>_},pos_integer(),integer(),[any(),...]) -> [any(),...]
Type specification 'Elixir.OMG.Watcher.DB.Transaction':update_with(mined_block()) -> {'ok',any()} is a subtype of the success typing: 'Elixir.OMG.Watcher.DB.Transaction':update_with(#{'blkhash':=_, 'blknum':=_, 'eth_height':=_, 'timestamp':=_, 'transactions':=_, _=>_}) -> {'ok',_}
Type specification 'Elixir.OMG.Watcher.DB.TxOutput':compose_utxo_exit('Elixir.OMG.Utxo.Position':t()) -> {'ok',exit_t()} | {'error','utxo_not_found'} is a subtype of the success typing: 'Elixir.OMG.Watcher.DB.TxOutput':compose_utxo_exit({'utxo_position',_,_,_}) -> any()
Type specification 'Elixir.OMG.Watcher.DB.TxOutput':create_inputs('Elixir.OMG.State.Transaction':any_flavor_t(),binary()) -> [tuple()] is a subtype of the success typing: 'Elixir.OMG.Watcher.DB.TxOutput':create_inputs(_,_) -> any()
Type specification 'Elixir.OMG.Watcher.DB.TxOutput':create_outputs(pos_integer(),integer(),binary(),'Elixir.OMG.State.Transaction':any_flavor_t()) -> [map()] is a subtype of the success typing: 'Elixir.OMG.Watcher.DB.TxOutput':create_outputs(_,_,_,_) -> any()
Type specification 'Elixir.OMG.Watcher.DB.TxOutput':get_balance('Elixir.OMG.Crypto':address_t()) -> [balance()] is a subtype of the success typing: 'Elixir.OMG.Watcher.DB.TxOutput':get_balance(_) -> any()
Type specification 'Elixir.OMG.Watcher.DB.TxOutput':get_by_position('Elixir.OMG.Utxo.Position':t()) -> map() | 'nil' is a subtype of the success typing: 'Elixir.OMG.Watcher.DB.TxOutput':get_by_position({'utxo_position',_,_,_}) -> any()
Type specification 'Elixir.OMG.Watcher.DB.TxOutput':get_sorted_grouped_utxos('Elixir.OMG.Crypto':address_t()) -> #{'Elixir.OMG.Crypto':address_t()=>[#{'__struct__':='Elixir.OMG.Watcher.DB.TxOutput','__meta__':=term(),'amount':=term(),'blknum':=term(),'creating_deposit':=term(),'creating_transaction':=term(),'creating_txhash':=term(),'currency':=term(),'deposit':=term(),'exit':=term(),'oindex':=term(),'owner':=term(),'proof':=term(),'spending_exit':=term(),'spending_transaction':=term(),'spending_tx_oindex':=term(),'spending_txhash':=term(),'txindex':=term()}]} is a subtype of the success typing: 'Elixir.OMG.Watcher.DB.TxOutput':get_sorted_grouped_utxos(_) -> any()
Type specification 'Elixir.OMG.Watcher.DB.TxOutput':spend_utxos([map()]) -> 'ok' is a subtype of the success typing: 'Elixir.OMG.Watcher.DB.TxOutput':spend_utxos(_) -> any()
Type specification 'Elixir.OMG.Watcher.Eventer.Core':pair_events_with_topics(any() | 'Elixir.OMG.Watcher.Event':t()) -> [{'Elixir.String':t(),'Elixir.String':t(),'Elixir.OMG.Watcher.Event':t()}] is a subtype of the success typing: 'Elixir.OMG.Watcher.Eventer.Core':pair_events_with_topics(_) -> [any()]
Type specification 'Elixir.OMG.Watcher.ExitProcessor':create_challenge('Elixir.OMG.Utxo.Position':t()) -> {'ok','Elixir.OMG.Watcher.ExitProcessor.StandardExitChallenge':t()} | {'error','utxo_not_spent' | 'exit_not_found'} is a subtype of the success typing: 'Elixir.OMG.Watcher.ExitProcessor':create_challenge(_) -> any()
Type specification 'Elixir.OMG.Watcher.ExitProcessor':fill_request_with_spending_data('Elixir.OMG.Watcher.ExitProcessor.Request':t(),'Elixir.OMG.Watcher.ExitProcessor.Core':t()) -> 'Elixir.OMG.Watcher.ExitProcessor.Request':t() is not equal to the success typing: 'Elixir.OMG.Watcher.ExitProcessor':fill_request_with_spending_data(#{'__struct__':='Elixir.OMG.Watcher.ExitProcessor.Request', 'blknum_now':='nil', 'blknums_to_get':=[], 'blocks_result':=[], 'eth_height_now':='nil', 'ife_input_spending_blocks_result':=[], 'ife_input_spends_to_get':=[], 'ife_input_utxo_exists_result':=[], 'ife_input_utxos_to_check':=[], 'piggybacked_blknums_to_get':=[], 'se_creating_blocks_result':=[], 'se_creating_blocks_to_get':=[], 'se_exit_id_result':='nil', 'se_exit_id_to_get':='nil', 'se_exiting_pos':='nil', 'se_spending_blocks_result':=[], 'se_spending_blocks_to_get':=[], 'spends_to_get':=[], 'utxo_exists_result':=[], 'utxos_to_check':=[]},#{'__struct__':='Elixir.OMG.Wa
Type specification 'Elixir.OMG.Watcher.ExitProcessor':get_active_in_flight_exits() -> {'ok','Elixir.OMG.Watcher.ExitProcessor.Core':in_flight_exits_response_t()} is a subtype of the success typing: 'Elixir.OMG.Watcher.ExitProcessor':get_active_in_flight_exits() -> any()
Type specification 'Elixir.OMG.Watcher.ExitProcessor':get_competitor_for_ife(binary()) -> {'ok','Elixir.OMG.Watcher.ExitProcessor.Core':competitor_data_t()} | {'error','competitor_not_found'} | {'error','no_viable_competitor_found'} is a subtype of the success typing: 'Elixir.OMG.Watcher.ExitProcessor':get_competitor_for_ife(_) -> any()
Type specification 'Elixir.OMG.Watcher.ExitProcessor':get_input_challenge_data('Elixir.OMG.State.Transaction.Signed':tx_bytes(),'Elixir.OMG.State.Transaction':input_index_t()) -> {'ok','Elixir.OMG.Watcher.ExitProcessor.Core':input_challenge_data()} | {'error','Elixir.OMG.Watcher.ExitProcessor.Core':piggyback_challenge_data_error()} is a subtype of the success typing: 'Elixir.OMG.Watcher.ExitProcessor':get_input_challenge_data(_,_) -> any()
Type specification 'Elixir.OMG.Watcher.ExitProcessor':get_output_challenge_data('Elixir.OMG.State.Transaction.Signed':tx_bytes(),'Elixir.OMG.State.Transaction':input_index_t()) -> {'ok','Elixir.OMG.Watcher.ExitProcessor.Core':output_challenge_data()} | {'error','Elixir.OMG.Watcher.ExitProcessor.Core':piggyback_challenge_data_error()} is a subtype of the success typing: 'Elixir.OMG.Watcher.ExitProcessor':get_output_challenge_data(_,_) -> any()
Type specification 'Elixir.OMG.Watcher.ExitProcessor':prove_canonical_for_ife(binary()) -> {'ok','Elixir.OMG.Watcher.ExitProcessor.Core':prove_canonical_data_t()} | {'error','no_viable_canonical_proof_found'} is a subtype of the success typing: 'Elixir.OMG.Watcher.ExitProcessor':prove_canonical_for_ife(_) -> any()
Type specification 'Elixir.OMG.Watcher.ExitProcessor':update_with_ife_txs_from_blocks('Elixir.OMG.Watcher.ExitProcessor.Core':t()) -> 'Elixir.OMG.Watcher.ExitProcessor.Core':t() is a subtype of the success typing: 'Elixir.OMG.Watcher.ExitProcessor':update_with_ife_txs_from_blocks(#{'__struct__':='Elixir.OMG.Watcher.ExitProcessor.Core', 'competitors':=#{<<_:256>>=>#{'__struct__':='Elixir.OMG.Watcher.ExitProcessor.CompetitorInfo', 'competing_input_index':=0 | 1 | 2 | 3, 'competing_input_signature':=<<_:520>>, 'tx':=map()}}, 'exits':=#{{'utxo_position',non_neg_integer(),non_neg_integer(),non_neg_integer()}=>#{'__struct__':='Elixir.OMG.Watcher.ExitProcessor.ExitInfo', 'amount':=non_neg_integer(), 'currency':=<<_:160>>, 'eth_height':=pos_integer(), 'is_active':=boolean(), 'owner':=<<_:160>>}}, 'in_flight_exits':=#{<<_:256>>=>#{'__struct__':='Elixir.OMG.Watcher.ExitProcessor.InFlightExitInfo', 'contract_id':=<<_:192>>, 'contract_tx_pos':='nil' | {_,_,_,_},
Type specification 'Elixir.OMG.Watcher.ExitProcessor.Core':challenge_exits(t(),[map()]) -> {t(),[any()]} is a subtype of the success typing: 'Elixir.OMG.Watcher.ExitProcessor.Core':challenge_exits(#{'__struct__':='Elixir.OMG.Watcher.ExitProcessor.Core', 'exits':=map(), _=>_},_) -> {#{'__struct__':='Elixir.OMG.Watcher.ExitProcessor.Core', 'exits':=map(), _=>_},[any()]}
Type specification 'Elixir.OMG.Watcher.ExitProcessor.Core':challenge_piggybacks(t(),[map()]) -> {t(),[any()]} is a subtype of the success typing: 'Elixir.OMG.Watcher.ExitProcessor.Core':challenge_piggybacks(#{'__struct__':='Elixir.OMG.Watcher.ExitProcessor.Core', _=>_},_) -> {#{'__struct__':='Elixir.OMG.Watcher.ExitProcessor.Core', 'in_flight_exits':=map(), _=>_},[any()]}
Type specification 'Elixir.OMG.Watcher.ExitProcessor.Core':check_validity('Elixir.OMG.Watcher.ExitProcessor.Request':t(),t()) -> check_validity_result_t() is not equal to the success typing: 'Elixir.OMG.Watcher.ExitProcessor.Core':check_validity(#{'__struct__':='Elixir.OMG.Watcher.ExitProcessor.Request', 'blknum_now':='nil' | pos_integer(), 'blknums_to_get':=[pos_integer()], 'blocks_result':=[map()], 'eth_height_now':=pos_integer(), 'ife_input_spending_blocks_result':=[map()], 'ife_input_spends_to_get':=[{_,_,_,_}], 'ife_input_utxo_exists_result':=[boolean()], 'ife_input_utxos_to_check':=[{_,_,_,_}], 'piggybacked_blknums_to_get':=[pos_integer()], 'se_creating_blocks_result':=[map()], 'se_creating_blocks_to_get':=[pos_integer()], 'se_exit_id_result':='nil' | pos_integer(), 'se_exit_id_to_get':='nil' | binary(), 'se_exiting_pos':='nil' | {'utxo_position',non_neg_integer(),non_neg_integer(),non_neg_integer()}, 'se_spending_blocks_result':=[map()], '
Type specification 'Elixir.OMG.Watcher.ExitProcessor.Core':determine_ife_input_utxos_existence_to_get('Elixir.OMG.Watcher.ExitProcessor.Request':t(),t()) -> 'Elixir.OMG.Watcher.ExitProcessor.Request':t() is not equal to the success typing: 'Elixir.OMG.Watcher.ExitProcessor.Core':determine_ife_input_utxos_existence_to_get(#{'__struct__':='Elixir.OMG.Watcher.ExitProcessor.Request', 'blknum_now':=integer(), 'ife_input_utxos_to_check':=_, _=>_},#{'__struct__':='Elixir.OMG.Watcher.ExitProcessor.Core', 'in_flight_exits':=map(), _=>_}) -> #{'__struct__':='Elixir.OMG.Watcher.ExitProcessor.Request', 'blknum_now':=integer(), 'ife_input_utxos_to_check':=[any()], _=>_}
Type specification 'Elixir.OMG.Watcher.ExitProcessor.Core':determine_ife_spends_to_get('Elixir.OMG.Watcher.ExitProcessor.Request':t(),'Elixir.OMG.Watcher.ExitProcessor.Core':t()) -> 'Elixir.OMG.Watcher.ExitProcessor.Request':t() is a subtype of the success typing: 'Elixir.OMG.Watcher.ExitProcessor.Core':determine_ife_spends_to_get(#{'__struct__':='Elixir.OMG.Watcher.ExitProcessor.Request', 'ife_input_spends_to_get':=_, 'ife_input_utxo_exists_result':=_, 'ife_input_utxos_to_check':=_, _=>_},#{'__struct__':='Elixir.OMG.Watcher.ExitProcessor.Core', 'in_flight_exits':=map(), _=>_}) -> #{'__struct__':='Elixir.OMG.Watcher.ExitProcessor.Request', 'ife_input_spends_to_get':=[any()], 'ife_input_utxo_exists_result':=_, 'ife_input_utxos_to_check':=_, _=>_}
Type specification 'Elixir.OMG.Watcher.ExitProcessor.Core':determine_spends_to_get('Elixir.OMG.Watcher.ExitProcessor.Request':t(),'Elixir.OMG.Watcher.ExitProcessor.Core':t()) -> 'Elixir.OMG.Watcher.ExitProcessor.Request':t() is a subtype of the success typing: 'Elixir.OMG.Watcher.ExitProcessor.Core':determine_spends_to_get(#{'__struct__':='Elixir.OMG.Watcher.ExitProcessor.Request', 'spends_to_get':=_, 'utxo_exists_result':=_, 'utxos_to_check':=_, _=>_},#{'__struct__':='Elixir.OMG.Watcher.ExitProcessor.Core', 'in_flight_exits':=map(), _=>_}) -> #{'__struct__':='Elixir.OMG.Watcher.ExitProcessor.Request', 'spends_to_get':=[any()], 'utxo_exists_result':=_, 'utxos_to_check':=_, _=>_}
Type specification 'Elixir.OMG.Watcher.ExitProcessor.Core':determine_utxo_existence_to_get('Elixir.OMG.Watcher.ExitProcessor.Request':t(),t()) -> 'Elixir.OMG.Watcher.ExitProcessor.Request':t() is not equal to the success typing: 'Elixir.OMG.Watcher.ExitProcessor.Core':determine_utxo_existence_to_get(#{'__struct__':='Elixir.OMG.Watcher.ExitProcessor.Request', 'blknum_now':=integer(), 'utxos_to_check':=_, _=>_},#{'__struct__':='Elixir.OMG.Watcher.ExitProcessor.Core', 'competitors':=#{<<_:256>>=>map()}, 'exits':=#{{_,_,_,_}=>map()}, 'in_flight_exits':=#{<<_:256>>=>map()}, 'sla_margin':=non_neg_integer()}) -> #{'__struct__':='Elixir.OMG.Watcher.ExitProcessor.Request', 'blknum_now':=integer(), 'utxos_to_check':=[any()], _=>_}
Type specification 'Elixir.OMG.Watcher.ExitProcessor.Core':finalize_exits(t(),validities::{['Elixir.OMG.Utxo.Position':t()],['Elixir.OMG.Utxo.Position':t()]}) -> {t(),[any()],[any()]} is a subtype of the success typing: 'Elixir.OMG.Watcher.ExitProcessor.Core':finalize_exits(#{'__struct__':='Elixir.OMG.Watcher.ExitProcessor.Core', 'exits':=map(), _=>_},{_,_}) -> {#{'__struct__':='Elixir.OMG.Watcher.ExitProcessor.Core', 'exits':=map(), _=>_},[any()],[any()]}
Type specification 'Elixir.OMG.Watcher.ExitProcessor.Core':finalize_in_flight_exits(t(),[map()],map()) -> {'ok',t(),[any()]} | {'unknown_piggybacks',[any()]} | {'unknown_in_flight_exit','Elixir.MapSet':t(non_neg_integer())} is a subtype of the success typing: 'Elixir.OMG.Watcher.ExitProcessor.Core':finalize_in_flight_exits(#{'__struct__':='Elixir.OMG.Watcher.ExitProcessor.Core', 'in_flight_exits':=_, _=>_},_,_) -> {'unknown_in_flight_exit','Elixir.MapSet':t(_)} | {'unknown_piggybacks',[any()]} | {'ok',#{'__struct__':='Elixir.OMG.Watcher.ExitProcessor.Core', 'in_flight_exits':=map(), _=>_},[any()]}
Type specification 'Elixir.OMG.Watcher.ExitProcessor.Core':get_active_in_flight_exits('Elixir.OMG.Watcher.ExitProcessor.Core':t()) -> [map()] is a subtype of the success typing: 'Elixir.OMG.Watcher.ExitProcessor.Core':get_active_in_flight_exits(#{'__struct__':='Elixir.OMG.Watcher.ExitProcessor.Core', 'in_flight_exits':=_, _=>_}) -> [any()]
Type specification 'Elixir.OMG.Watcher.ExitProcessor.Core':get_ifes_to_piggyback(t()) -> ['Elixir.OMG.Watcher.ExitProcessor.InFlightExitInfo':t()] is a subtype of the success typing: 'Elixir.OMG.Watcher.ExitProcessor.Core':get_ifes_to_piggyback(#{'__struct__':='Elixir.OMG.Watcher.ExitProcessor.Core', 'competitors':=#{<<_:256>>=>map()}, 'exits':=#{{_,_,_,_}=>map()}, 'in_flight_exits':=#{<<_:256>>=>map()}, 'sla_margin':=non_neg_integer()}) -> [any()]
Type specification 'Elixir.OMG.Watcher.ExitProcessor.Core':get_invalid_ife_challenges(t()) -> [binary()] is a subtype of the success typing: 'Elixir.OMG.Watcher.ExitProcessor.Core':get_invalid_ife_challenges(#{'__struct__':='Elixir.OMG.Watcher.ExitProcessor.Core', 'competitors':=#{<<_:256>>=>map()}, 'exits':=#{{_,_,_,_}=>map()}, 'in_flight_exits':=#{<<_:256>>=>map()}, 'sla_margin':=non_neg_integer()}) -> [any()]
Type specification 'Elixir.OMG.Watcher.ExitProcessor.Core':get_invalid_piggybacks_events('Elixir.OMG.Watcher.ExitProcessor.Request':t(),'Elixir.OMG.Watcher.ExitProcessor.Core':t()) -> ['Elixir.OMG.Watcher.Event.InvalidPiggyback':t()] is a subtype of the success typing: 'Elixir.OMG.Watcher.ExitProcessor.Core':get_invalid_piggybacks_events(#{'__struct__':='Elixir.OMG.Watcher.ExitProcessor.Request', 'blknum_now':='nil' | pos_integer(), 'blknums_to_get':=[pos_integer()], 'blocks_result':=[map()], 'eth_height_now':='nil' | pos_integer(), 'ife_input_spending_blocks_result':=[map()], 'ife_input_spends_to_get':=[{_,_,_,_}], 'ife_input_utxo_exists_result':=[boolean()], 'ife_input_utxos_to_check':=[{_,_,_,_}], 'piggybacked_blknums_to_get':=[pos_integer()], 'se_creating_blocks_result':=[map()], 'se_creating_blocks_to_get':=[pos_integer()], 'se_exit_id_result':='nil' | pos_integer(), 'se_exit_id_to_get':='nil' | binary(), 'se_exiting_pos':='nil' | {'utxo_pos
Type specification 'Elixir.OMG.Watcher.ExitProcessor.Core':get_piggyback_challenge_data('Elixir.OMG.Watcher.ExitProcessor.Request':t(),'Elixir.OMG.Watcher.ExitProcessor.Core':t(),binary(),piggyback_t()) -> {'ok',input_challenge_data() | output_challenge_data()} | {'error',piggyback_challenge_data_error()} is a subtype of the success typing: 'Elixir.OMG.Watcher.ExitProcessor.Core':get_piggyback_challenge_data(#{'__struct__':='Elixir.OMG.Watcher.ExitProcessor.Request', 'blocks_result':=_, _=>_},_,binary(),{'input',_} | {'output',_}) -> {'error','ife_not_known_for_tx' | 'malformed_address' | 'malformed_inputs' | 'malformed_metadata' | 'malformed_outputs' | 'malformed_transaction' | 'malformed_transaction_rlp' | 'no_double_spend_on_particular_piggyback'} | {'ok',#{'in_flight_input_index':=0 | 1 | 2 | 3 | 4 | 5 | 6 | 7, 'in_flight_txbytes':=binary(), 'spending_input_index':=0 | 1 | 2 | 3, 'spending_sig':=<<_:520>>, 'spending_txbytes':=binary(), 'in_fl
Type specification 'Elixir.OMG.Watcher.ExitProcessor.Core':handle_spent_blknum_result([spent_blknum_result_t()],['Elixir.OMG.Utxo.Position':t()]) -> [pos_integer()] is a subtype of the success typing: 'Elixir.OMG.Watcher.ExitProcessor.Core':handle_spent_blknum_result(_,_) -> [any()]
Type specification 'Elixir.OMG.Watcher.ExitProcessor.Core':init(db_exits::[{{pos_integer(),non_neg_integer(),non_neg_integer()},map()}],db_in_flight_exits::[{'Elixir.OMG.State.Transaction':tx_hash(),'Elixir.OMG.Watcher.ExitProcessor.InFlightExitInfo':t()}],db_competitors::[{'Elixir.OMG.State.Transaction':tx_hash(),'Elixir.OMG.Watcher.ExitProcessor.CompetitorInfo':t()}],sla_margin::non_neg_integer()) -> {'ok',t()} is a subtype of the success typing: 'Elixir.OMG.Watcher.ExitProcessor.Core':init(_,_,_,_) -> {'ok',#{'__struct__':='Elixir.OMG.Watcher.ExitProcessor.Core', 'competitors':=map(), 'exits':=map(), 'in_flight_exits':=map(), 'sla_margin':=_}}
Type specification 'Elixir.OMG.Watcher.ExitProcessor.Core':new_exits(t(),[map()],[map()]) -> {t(),[any()]} | {'error','unexpected_events'} is a subtype of the success typing: 'Elixir.OMG.Watcher.ExitProcessor.Core':new_exits(_,_,_) -> {'error' | #{'__struct__':='Elixir.OMG.Watcher.ExitProcessor.Core', 'exits':=map(), _=>_},'unexpected_events' | [any()]}
Type specification 'Elixir.OMG.Watcher.ExitProcessor.Core':new_ife_challenges(t(),[map()]) -> {t(),[any()]} is a subtype of the success typing: 'Elixir.OMG.Watcher.ExitProcessor.Core':new_ife_challenges(#{'__struct__':='Elixir.OMG.Watcher.ExitProcessor.Core', _=>_},_) -> {#{'__struct__':='Elixir.OMG.Watcher.ExitProcessor.Core', 'competitors':=map(), 'in_flight_exits':=map(), _=>_},[any()]}
Type specification 'Elixir.OMG.Watcher.ExitProcessor.Core':new_in_flight_exits(t(),[map()],[map()]) -> {t(),[any()]} | {'error','unexpected_events'} is a subtype of the success typing: 'Elixir.OMG.Watcher.ExitProcessor.Core':new_in_flight_exits(_,_,_) -> {'error' | #{'__struct__':='Elixir.OMG.Watcher.ExitProcessor.Core', 'in_flight_exits':=map(), _=>_},'unexpected_events' | [any()]}
Type specification 'Elixir.OMG.Watcher.ExitProcessor.Core':new_piggybacks(t(),[#{'tx_hash':='Elixir.OMG.State.Transaction':tx_hash(),'output_index':=contract_piggyback_offset_t()}]) -> {t(),[any()]} is a subtype of the success typing: 'Elixir.OMG.Watcher.ExitProcessor.Core':new_piggybacks(#{'__struct__':='Elixir.OMG.Watcher.ExitProcessor.Core', _=>_},maybe_improper_list()) -> {#{'__struct__':='Elixir.OMG.Watcher.ExitProcessor.Core', 'in_flight_exits':=map(), _=>_},[any()]}
Type specification 'Elixir.OMG.Watcher.ExitProcessor.Core':prepare_available_piggyback('Elixir.OMG.Watcher.ExitProcessor.InFlightExitInfo':t()) -> ['Elixir.OMG.Watcher.Event.PiggybackAvailable':t()] is not equal to the success typing: 'Elixir.OMG.Watcher.ExitProcessor.Core':prepare_available_piggyback(#{'__struct__':='Elixir.OMG.Watcher.ExitProcessor.InFlightExitInfo', 'tx':=#{'__struct__':='Elixir.OMG.State.Transaction.Signed', 'raw_tx':=map(), 'signed_tx_bytes':='nil' | binary(), 'sigs':=[any()]}, _=>_}) -> [#{'__struct__':='Elixir.OMG.Watcher.Event.PiggybackAvailable', 'available_inputs':=[any()], 'available_outputs':=[any()], 'name':='piggyback_available', 'txbytes':=binary()}]
Type specification 'Elixir.OMG.Watcher.ExitProcessor.Core':prepare_utxo_exits_for_in_flight_exit_finalizations(t(),[map()]) -> {'ok',map()} | {'unknown_piggybacks',[any()]} | {'unknown_in_flight_exit','Elixir.MapSet':t(non_neg_integer())} is a subtype of the success typing: 'Elixir.OMG.Watcher.ExitProcessor.Core':prepare_utxo_exits_for_in_flight_exit_finalizations(#{'__struct__':='Elixir.OMG.Watcher.ExitProcessor.Core', 'in_flight_exits':=_, _=>_},_) -> {'ok',_} | {'unknown_in_flight_exit','Elixir.MapSet':t(_)} | {'unknown_piggybacks',[any()]}
Type specification 'Elixir.OMG.Watcher.ExitProcessor.Core':respond_to_in_flight_exits_challenges(t(),[map()]) -> {t(),[any()]} is a subtype of the success typing: 'Elixir.OMG.Watcher.ExitProcessor.Core':respond_to_in_flight_exits_challenges(#{'__struct__':='Elixir.OMG.Watcher.ExitProcessor.Core', _=>_},_) -> {#{'__struct__':='Elixir.OMG.Watcher.ExitProcessor.Core', 'in_flight_exits':=map(), _=>_},[any()]}
Type specification 'Elixir.OMG.Watcher.ExitProcessor.InFlightExitInfo':'is_invalidly_challenged?'(t()) -> boolean() is a subtype of the success typing: 'Elixir.OMG.Watcher.ExitProcessor.InFlightExitInfo':'is_invalidly_challenged?'(#{'__struct__':='Elixir.OMG.Watcher.ExitProcessor.InFlightExitInfo', _=>_}) -> boolean()
Type specification 'Elixir.OMG.Watcher.ExitProcessor.InFlightExitInfo':'is_viable_competitor?'(t(),'Elixir.OMG.Utxo.Position':t() | 'nil') -> boolean() is a subtype of the success typing: 'Elixir.OMG.Watcher.ExitProcessor.InFlightExitInfo':'is_viable_competitor?'(#{'__struct__':='Elixir.OMG.Watcher.ExitProcessor.InFlightExitInfo', 'oldest_competitor':=_, 'tx_seen_in_blocks_at':='nil' | {_,_}, _=>_},_) -> boolean()
Type specification 'Elixir.OMG.Watcher.ExitProcessor.InFlightExitInfo':finalize(t(),non_neg_integer()) -> {'ok',t()} | 'unknown_output_index' is a subtype of the success typing: 'Elixir.OMG.Watcher.ExitProcessor.InFlightExitInfo':finalize(#{'__struct__':='Elixir.OMG.Watcher.ExitProcessor.InFlightExitInfo', 'exit_map':=map(), _=>_},_) -> 'unknown_output_index' | {'ok',#{'__struct__':='Elixir.OMG.Watcher.ExitProcessor.InFlightExitInfo', 'exit_map':=map(), 'is_active':=boolean(), _=>_}}
Type specification 'Elixir.OMG.Watcher.ExitProcessor.InFlightExitInfo':get_piggybacked_outputs_positions(t()) -> ['Elixir.OMG.Utxo.Position':t()] is a subtype of the success typing: 'Elixir.OMG.Watcher.ExitProcessor.InFlightExitInfo':get_piggybacked_outputs_positions(#{'__struct__':='Elixir.OMG.Watcher.ExitProcessor.InFlightExitInfo', 'tx_seen_in_blocks_at':='nil' | {{_,_,_,_},_}, _=>_}) -> [any()]
Type specification 'Elixir.OMG.Watcher.ExitProcessor.InFlightExitInfo':piggyback(t(),non_neg_integer()) -> t() | {'error','non_existent_exit' | 'cannot_piggyback'} is a subtype of the success typing: 'Elixir.OMG.Watcher.ExitProcessor.InFlightExitInfo':piggyback(#{'__struct__':='Elixir.OMG.Watcher.ExitProcessor.InFlightExitInfo', _=>_},_) -> {'error','cannot_piggyback' | 'non_existent_exit'} | #{'__struct__':='Elixir.OMG.Watcher.ExitProcessor.InFlightExitInfo', 'exit_map':=map(), _=>_}
Type specification 'Elixir.OMG.Watcher.ExitProcessor.InFlightExitInfo':respond_to_challenge(t(),'Elixir.OMG.Utxo.Position':t()) -> t() | {'error','responded_with_too_young_tx' | 'cannot_respond'} is not equal to the success typing: 'Elixir.OMG.Watcher.ExitProcessor.InFlightExitInfo':respond_to_challenge(#{'__struct__':='Elixir.OMG.Watcher.ExitProcessor.InFlightExitInfo', _=>_},_) -> {'error','cannot_respond' | 'responded_with_too_young_tx'} | #{'__struct__':='Elixir.OMG.Watcher.ExitProcessor.InFlightExitInfo', 'contract_tx_pos':={'utxo_position',non_neg_integer(),non_neg_integer(),char()}, 'is_canonical':='true', 'oldest_competitor':={'utxo_position',non_neg_integer(),non_neg_integer(),char()}, _=>_}
Type specification 'Elixir.OMG.Watcher.ExitProcessor.InFlightExitInfo':respond_to_challenge(t(),'Elixir.OMG.Utxo.Position':t()) -> t() | {'error','responded_with_too_young_tx' | 'cannot_respond'} is not equal to the success typing: 'Elixir.OMG.Watcher.ExitProcessor.InFlightExitInfo':respond_to_challenge(#{'__struct__':='Elixir.OMG.Watcher.ExitProcessor.InFlightExitInfo', _=>_},_) -> {'error','cannot_respond' | 'responded_with_too_young_tx'} | #{'__struct__':='Elixir.OMG.Watcher.ExitProcessor.InFlightExitInfo', 'contract_tx_pos':={'utxo_position',non_neg_integer(),non_neg_integer(),non_neg_integer()}, 'is_canonical':='true', 'oldest_competitor':={'utxo_position',non_neg_integer(),non_neg_integer(),non_neg_integer()}, _=>_}
Type specification 'Elixir.OMG.Watcher.ExitProcessor.StandardExitChallenge':create_challenge('Elixir.OMG.Watcher.ExitProcessor.Request':t(),'Elixir.OMG.Watcher.ExitProcessor.Core':t()) -> {'ok','Elixir.OMG.Watcher.ExitProcessor.StandardExitChallenge':t()} | {'error','utxo_not_spent'} | {'error','exit_not_found'} is not equal to the success typing: 'Elixir.OMG.Watcher.ExitProcessor.StandardExitChallenge':create_challenge(#{'__struct__':='Elixir.OMG.Watcher.ExitProcessor.Request', 'se_exit_id_result':=_, 'se_exiting_pos':={'utxo_position',non_neg_integer(),non_neg_integer(),non_neg_integer()}, 'se_spending_blocks_result':=_, _=>_},#{'__struct__':='Elixir.OMG.Watcher.ExitProcessor.Core', 'competitors':=#{<<_:256>>=>#{'__struct__':='Elixir.OMG.Watcher.ExitProcessor.CompetitorInfo', 'competing_input_index':=0 | 1 | 2 | 3, 'competing_input_signature':=<<_:520>>, 'tx':=map()}}, 'exits':=#{{'utxo_position',non_neg_integer(),non_neg_int
Type specification 'Elixir.OMG.Watcher.ExitProcessor.StandardExitChallenge':determine_exit_txbytes('Elixir.OMG.Watcher.ExitProcessor.Request':t(),'Elixir.OMG.Watcher.ExitProcessor.Core':t()) -> 'Elixir.OMG.Watcher.ExitProcessor.Request':t() is not equal to the success typing: 'Elixir.OMG.Watcher.ExitProcessor.StandardExitChallenge':determine_exit_txbytes(#{'__struct__':='Elixir.OMG.Watcher.ExitProcessor.Request', 'se_creating_blocks_result':=_, 'se_exit_id_to_get':=_, 'se_exiting_pos':={'utxo_position',non_neg_integer(),non_neg_integer(),non_neg_integer()}, _=>_},#{'__struct__':='Elixir.OMG.Watcher.ExitProcessor.Core', 'exits':=_, _=>_}) -> #{'__struct__':='Elixir.OMG.Watcher.ExitProcessor.Request', 'se_creating_blocks_result':=_, 'se_exit_id_to_get':=binary(), 'se_exiting_pos':={'utxo_position',non_neg_integer(),non_neg_integer(),non_neg_integer()}, _=>_}
Type specification 'Elixir.OMG.Watcher.ExitProcessor.StandardExitChallenge':determine_standard_challenge_queries('Elixir.OMG.Watcher.ExitProcessor.Request':t(),'Elixir.OMG.Watcher.ExitProcessor.Core':t()) -> {'ok','Elixir.OMG.Watcher.ExitProcessor.Request':t()} | {'error','exit_not_found'} is not equal to the success typing: 'Elixir.OMG.Watcher.ExitProcessor.StandardExitChallenge':determine_standard_challenge_queries(#{'__struct__':='Elixir.OMG.Watcher.ExitProcessor.Request', 'se_exiting_pos':={'utxo_position',_,_,_}, _=>_},#{'__struct__':='Elixir.OMG.Watcher.ExitProcessor.Core', 'exits':=map(), _=>_}) -> any()
Type specification 'Elixir.OMG.Watcher.ExitProcessor.StandardExitChallenge':exiting_positions('Elixir.OMG.Watcher.ExitProcessor.Core':t()) -> ['Elixir.OMG.Utxo.Position':t()] is a subtype of the success typing: 'Elixir.OMG.Watcher.ExitProcessor.StandardExitChallenge':exiting_positions(#{'__struct__':='Elixir.OMG.Watcher.ExitProcessor.Core', 'exits':=_, _=>_}) -> [any()]
Type specification 'Elixir.OMG.Watcher.ExitProcessor.StandardExitChallenge':get_double_spends_by_utxo_pos('Elixir.OMG.Utxo.Position':t(),'Elixir.OMG.Watcher.ExitProcessor.Tools.KnownTx':t()) -> ['Elixir.OMG.Watcher.ExitProcessor.Tools.DoubleSpend':t()] is a subtype of the success typing: 'Elixir.OMG.Watcher.ExitProcessor.StandardExitChallenge':get_double_spends_by_utxo_pos({'utxo_position',non_neg_integer(),non_neg_integer(),non_neg_integer()},#{'__struct__':='Elixir.OMG.Watcher.ExitProcessor.Tools.KnownTx', 'signed_tx':=#{'__struct__':='Elixir.OMG.State.Transaction.Signed', 'raw_tx':=#{'__struct__':='Elixir.OMG.State.Transaction', 'inputs':=[any()], 'metadata':='nil' | binary(), 'outputs':=[any()]}, 'signed_tx_bytes':='nil' | binary(), 'sigs':=[<<_:520>>]}, 'utxo_pos':='nil' | {'utxo_position',non_neg_integer(),non_neg_integer(),non_neg_integer()}}) -> [#{'__struct__':='Elixir.OMG.Watcher.ExitProcessor.Tools.DoubleSpend', 'ind
Type specification 'Elixir.OMG.Watcher.ExitProcessor.StandardExitChallenge':get_invalid('Elixir.OMG.Watcher.ExitProcessor.Core':t(),#{'Elixir.OMG.Utxo.Position':t()=>boolean()},pos_integer()) -> {#{'Elixir.OMG.Utxo.Position':t()=>'Elixir.OMG.Watcher.ExitProcessor.ExitInfo':t()},#{'Elixir.OMG.Utxo.Position':t()=>'Elixir.OMG.Watcher.ExitProcessor.ExitInfo':t()}} is a subtype of the success typing: 'Elixir.OMG.Watcher.ExitProcessor.StandardExitChallenge':get_invalid(#{'__struct__':='Elixir.OMG.Watcher.ExitProcessor.Core', 'competitors':=#{<<_:256>>=>map()}, 'exits':=#{{_,_,_,_}=>map()}, 'in_flight_exits':=#{<<_:256>>=>map()}, 'sla_margin':=non_neg_integer()},_,_) -> {map(),map()}
Type specification 'Elixir.OMG.Watcher.ExitProcessor.StandardExitChallenge':get_invalid_exits_based_on_ifes('Elixir.OMG.Watcher.ExitProcessor.Core':t()) -> [#{'Elixir.OMG.Utxo.Position':t()=>'Elixir.OMG.Watcher.ExitProcessor.ExitInfo':t()}] is a subtype of the success typing: 'Elixir.OMG.Watcher.ExitProcessor.StandardExitChallenge':get_invalid_exits_based_on_ifes(#{'__struct__':='Elixir.OMG.Watcher.ExitProcessor.Core', 'competitors':=map(), 'exits':=_, 'in_flight_exits':=map(), 'sla_margin':=_, _=>_}) -> [any()]
Type specification 'Elixir.OMG.Watcher.ExitProcessor.Tools':double_spends_from_known_tx([{'Elixir.OMG.Utxo.Position':t(),non_neg_integer()}],'Elixir.OMG.Watcher.ExitProcessor.Tools.KnownTx':t()) -> ['Elixir.OMG.Watcher.ExitProcessor.Tools.DoubleSpend':t()] is a subtype of the success typing: 'Elixir.OMG.Watcher.ExitProcessor.Tools':double_spends_from_known_tx(maybe_improper_list(),#{'__struct__':='Elixir.OMG.Watcher.ExitProcessor.Tools.KnownTx', 'signed_tx':=#{'__struct__':='Elixir.OMG.State.Transaction' | 'Elixir.OMG.State.Transaction.Recovered' | 'Elixir.OMG.State.Transaction.Signed', 'inputs'=>[any()], 'metadata'=>'nil' | binary(), 'outputs'=>[any()], 'raw_tx'=>map(), 'signed_tx'=>map(), 'signed_tx_bytes'=>'nil' | binary(), 'sigs'=>[any()], 'spenders'=>[any()], 'tx_hash'=><<_:256>>}, _=>_}) -> [any()]
Type specification 'Elixir.OMG.Watcher.ExitProcessor.Tools':find_sig('Elixir.OMG.State.Transaction.Signed':t(),'Elixir.OMG.Crypto':address_t()) -> {'ok','Elixir.OMG.Crypto':sig_t()} | 'nil' is a subtype of the success typing: 'Elixir.OMG.Watcher.ExitProcessor.Tools':find_sig(#{'__struct__':='Elixir.OMG.State.Transaction.Signed', 'raw_tx':=#{'__struct__':='Elixir.OMG.State.Transaction', 'inputs':=[any()], 'metadata':='nil' | binary(), 'outputs':=[any()]}, 'sigs':=_, _=>_},_) -> 'nil' | {'ok',_}
Type specification 'Elixir.OMG.Watcher.HttpRPC.Client':get_block(binary(),binary()) -> response_t() is a subtype of the success typing: 'Elixir.OMG.Watcher.HttpRPC.Client':get_block(binary(),_) -> {'error',{'client_error',_} | {'malformed_response',_} | {'server_error',_}} | {'ok',map()}
Type specification 'Elixir.OMG.Watcher.HttpRPC.Client':submit(binary(),binary()) -> response_t() is a subtype of the success typing: 'Elixir.OMG.Watcher.HttpRPC.Client':submit(binary(),_) -> {'error',{'client_error',_} | {'malformed_response',_} | {'server_error',_}} | {'ok',map()}
Type specification 'Elixir.OMG.Watcher.Monitor':pop_child_from_dead_pid(pid(),['Elixir.OMG.Watcher.Monitor.Child':t()]) -> {'Elixir.OMG.Watcher.Monitor.Child':t(),['Elixir.OMG.Watcher.Monitor.Child':t()]} | {'nil',['Elixir.OMG.Watcher.Monitor.Child':t()]} is a subtype of the success typing: 'Elixir.OMG.Watcher.Monitor':pop_child_from_dead_pid(_,[any()]) -> {_,[any()]}
Type specification 'Elixir.OMG.Watcher.TestHelper':decode16(map(),[any()]) -> map() is a subtype of the success typing: 'Elixir.OMG.Watcher.TestHelper':decode16(_,_) -> map()
Type specification 'Elixir.OMG.Watcher.UtxoSelection':create_advice(#{'Elixir.OMG.State.Transaction':currency()=>[#{'__struct__':='Elixir.OMG.Watcher.DB.TxOutput','__meta__':=term(),'amount':=term(),'blknum':=term(),'creating_deposit':=term(),'creating_transaction':=term(),'creating_txhash':=term(),'currency':=term(),'deposit':=term(),'exit':=term(),'oindex':=term(),'owner':=term(),'proof':=term(),'spending_exit':=term(),'spending_transaction':=term(),'spending_tx_oindex':=term(),'spending_txhash':=term(),'txindex':=term()}]},order_t()) -> advice_t() is a subtype of the success typing: 'Elixir.OMG.Watcher.UtxoSelection':create_advice(#{<<_:160>>=>[map()]},#{'fee':=#{'amount':=_, 'currency':=_, _=>_}, 'owner':=_, 'payments':=_, _=>_}) -> {'error','empty_transaction' | 'too_many_outputs'} | {'ok',#{'result':='complete' | 'intermediate', 'transactions':=[any()]}} | {'error','insufficient_funds',[any()]}
Type specification 'Elixir.OMG.Watcher.UtxoSelection':select_utxo(#{'Elixir.OMG.State.Transaction':currency()=>[#{'__struct__':='Elixir.OMG.Watcher.DB.TxOutput','__meta__':=term(),'amount':=term(),'blknum':=term(),'creating_deposit':=term(),'creating_transaction':=term(),'creating_txhash':=term(),'currency':=term(),'deposit':=term(),'exit':=term(),'oindex':=term(),'owner':=term(),'proof':=term(),'spending_exit':=term(),'spending_transaction':=term(),'spending_tx_oindex':=term(),'spending_txhash':=term(),'txindex':=term()}]},#{'Elixir.OMG.State.Transaction':currency()=>pos_integer()}) -> [{'Elixir.OMG.State.Transaction':currency(),{integer(),[#{'__struct__':='Elixir.OMG.Watcher.DB.TxOutput','__meta__':=term(),'amount':=term(),'blknum':=term(),'creating_deposit':=term(),'creating_transaction':=term(),'creating_txhash':=term(),'currency':=term(),'deposit':=term(),'exit':=term(),'oindex':=term(),'owner':=term(),'proof':=term(),'spending_exit':=term(),'spen
Type specification 'Elixir.OMG.WatcherRPC.Web.Validator.Constraints':parse(#{binary()=>any()}) -> {'ok','Elixir.Keyword':t()} | {'error',any()} is a subtype of the success typing: 'Elixir.OMG.WatcherRPC.Web.Validator.Constraints':parse(_) -> any()
Type specification 'Elixir.OMG.WatcherRPC.Web.Validator.Order':parse(map()) -> {'ok','Elixir.OMG.Watcher.UtxoSelection':order_t()} | {'error',any()} is a subtype of the success typing: 'Elixir.OMG.WatcherRPC.Web.Validator.Order':parse(map()) -> {'error',_} | {'ok',#{'fee':=#{'amount':=_, 'currency':=_}, 'metadata':=_, 'owner':=_, 'payments':=[any()]}}
Type specification 'Elixir.OMG.Utils.Paginator':set_data([any()],t()) -> t() is a subtype of the success typing: 'Elixir.OMG.Utils.Paginator':set_data(maybe_improper_list(),#{'__struct__':='Elixir.OMG.Utils.Paginator', 'data':=_, _=>_}) -> #{'__struct__':='Elixir.OMG.Utils.Paginator', 'data':=maybe_improper_list(), _=>_}
Type specification 'Elixir.OMG.State.Transaction.Signed':'decode!'(tx_bytes()) -> t() is a subtype of the success typing: 'Elixir.OMG.State.Transaction.Signed':'decode!'(binary()) -> #{'__struct__':='Elixir.OMG.State.Transaction.Signed', 'raw_tx':=#{'__struct__':='Elixir.OMG.State.Transaction', 'inputs':=[map()], 'metadata':='nil' | binary(), 'outputs':=[map()]}, 'signed_tx_bytes':='nil' | binary(), 'sigs':=[<<_:520>>]}
Type specification 'Elixir.OMG.Watcher.ExitProcessor.KnownTx':group_txs_by_input('Elixir.Enumerable':t()) -> known_txs_by_input_t() is a subtype of the success typing: 'Elixir.OMG.Watcher.ExitProcessor.KnownTx':group_txs_by_input(_) -> map()
Type specification 'Elixir.OMG.Watcher.ExitProcessor.StandardExitChallenge':get_ife_based_on_utxo('Elixir.OMG.Utxo.Position':t(),'Elixir.OMG.Watcher.ExitProcessor.Core':t()) -> 'Elixir.OMG.Watcher.ExitProcessor.KnownTx':t() | 'nil' is a subtype of the success typing: 'Elixir.OMG.Watcher.ExitProcessor.StandardExitChallenge':get_ife_based_on_utxo({'utxo_position',_,_,_},#{'__struct__':='Elixir.OMG.Watcher.ExitProcessor.Core', 'competitors':=map(), 'exits':=_, 'in_flight_exits':=map(), _=>_}) -> any()
Type specification 'Elixir.OMG.Watcher.ExitProcessor.StandardExitChallenge':get_double_spend_for_standard_exit('Elixir.OMG.Block':t() | 'Elixir.OMG.Watcher.ExitProcessor.KnownTx':t(),'Elixir.OMG.Utxo.Position':t()) -> 'Elixir.OMG.Watcher.ExitProcessor.DoubleSpend':t() | 'nil' is a subtype of the success typing: 'Elixir.OMG.Watcher.ExitProcessor.StandardExitChallenge':get_double_spend_for_standard_exit(#{'__struct__':='Elixir.OMG.Block' | 'Elixir.OMG.Watcher.ExitProcessor.KnownTx', _=>_},{'utxo_position',non_neg_integer(),non_neg_integer(),non_neg_integer()}) -> any()
Type specification 'Elixir.OMG.Watcher.ExitProcessor.StandardExitChallenge':get_double_spends_by_utxo_pos('Elixir.OMG.Utxo.Position':t(),'Elixir.OMG.Watcher.ExitProcessor.KnownTx':t()) -> ['Elixir.OMG.Watcher.ExitProcessor.DoubleSpend':t()] is a subtype of the success typing: 'Elixir.OMG.Watcher.ExitProcessor.StandardExitChallenge':get_double_spends_by_utxo_pos({'utxo_position',non_neg_integer(),non_neg_integer(),non_neg_integer()},#{'__struct__':='Elixir.OMG.Watcher.ExitProcessor.KnownTx', 'signed_tx':=#{'__struct__':='Elixir.OMG.State.Transaction.Signed', 'raw_tx':=#{'__struct__':='Elixir.OMG.State.Transaction', 'inputs':=[any()], 'metadata':='nil' | binary(), 'outputs':=[any()]}, 'signed_tx_bytes':='nil' | binary(), 'sigs':=[<<_:520>>]}, 'utxo_pos':='nil' | {'utxo_position',non_neg_integer(),non_neg_integer(),non_neg_integer()}}) -> [#{'__struct__':='Elixir.OMG.Watcher.ExitProcessor.DoubleSpend', 'index':=non_neg_integer(), 'known_spent_index':=non_neg_integer(), 'known_tx':=#{'__struct__':='Elixir.OMG.Watcher.ExitProcessor.KnownTx', 'signed_tx':=map(), 'utxo_pos':='nil' | {_,_,_,_}}, 'utxo_pos':={'utxo_position',non_neg_integer(),non_neg_integer(),non_neg_integer()}}]
Type specification 'Elixir.OMG.Watcher.ExitProcessor.Tools':double_spends_from_known_tx([{'Elixir.OMG.Utxo.Position':t(),non_neg_integer()}],'Elixir.OMG.Watcher.ExitProcessor.KnownTx':t()) -> ['Elixir.OMG.Watcher.ExitProcessor.DoubleSpend':t()] is a subtype of the success typing: 'Elixir.OMG.Watcher.ExitProcessor.Tools':double_spends_from_known_tx(maybe_improper_list(),#{'__struct__':='Elixir.OMG.Watcher.ExitProcessor.KnownTx', 'signed_tx':=#{'__struct__':='Elixir.OMG.State.Transaction' | 'Elixir.OMG.State.Transaction.Recovered' | 'Elixir.OMG.State.Transaction.Signed', 'inputs'=>[any()], 'metadata'=>'nil' | binary(), 'outputs'=>[any()], 'raw_tx'=>map(), 'signed_tx'=>map(), 'signed_tx_bytes'=>'nil' | binary(), 'sigs'=>[any()], 'spenders'=>[any()], 'tx_hash'=><<_:256>>}, _=>_}) -> [any()]
Type specification 'Elixir.OMG.Watcher.ExitProcessor.Core':prepare_piggyback_challenge_response('Elixir.OMG.Watcher.ExitProcessor.InFlightExitInfo':t(),piggyback_t(),'Elixir.OMG.Watcher.ExitProcessor.DoubleSpend':t()) -> input_challenge_data() | output_challenge_data() is a subtype of the success typing: 'Elixir.OMG.Watcher.ExitProcessor.Core':prepare_piggyback_challenge_response(#{'__struct__':='Elixir.OMG.Watcher.ExitProcessor.InFlightExitInfo', 'contract_id':=<<_:192>>, 'contract_tx_pos':='nil' | {'utxo_position',non_neg_integer(),non_neg_integer(),non_neg_integer()}, 'eth_height':=pos_integer(), 'exit_map':=#{non_neg_integer()=>map()}, 'is_active':=boolean(), 'is_canonical':=boolean(), 'oldest_competitor':='nil' | {'utxo_position',non_neg_integer(),non_neg_integer(),non_neg_integer()}, 'timestamp':=non_neg_integer(), 'tx':=#{'__struct__':='Elixir.OMG.State.Transaction.Signed', 'raw_tx':=#{'__struct__':='Elixir.OMG.State.Transaction', 'inputs':=[any()], 'metadata':='nil' | binary(), 'outputs':=[any()]}, 'signed_tx_bytes':='nil' | binary(), 'sigs':=[<<_:520>>]}, 'tx_seen_in_blocks_at':='nil' | {{_,_,_,_},binary()}},{'input',_} | {'output',_},atom() | #{'known_spent_index':=integer(), 'known_tx':=atom() | #{'signed_tx':=#{'__struct__':='Elixir.OMG.State.Transaction' | 'Elixir.OMG.State.Transaction.Recovered' | 'Elixir.OMG.State.Transaction.Signed', 'sigs':=[any()], 'inputs'=>[any()], 'metadata'=>'nil' | binary(), 'outputs'=>[any()], 'raw_tx'=>map(), 'signed_tx'=>map(), 'signed_tx_bytes'=>'nil' | binary(), 'spenders'=>[any()], 'tx_hash'=><<_:256>>}, _=>_}, _=>_}) -> #{'in_flight_txbytes':=binary(), 'spending_input_index':=_, 'spending_sig':=_, 'spending_txbytes':=binary(), 'in_flight_input_index'=>_, 'in_flight_output_pos'=>_, 'in_flight_proof'=>binary()}
Type specification 'Elixir.OMG.Watcher.ExitProcessor.Core':get_invalid_piggybacks_events('Elixir.OMG.Watcher.ExitProcessor.Core':t(),'Elixir.OMG.Watcher.ExitProcessor.KnownTx':known_txs_by_input_t()) -> ['Elixir.OMG.Watcher.Event.InvalidPiggyback':t()] is a subtype of the success typing: 'Elixir.OMG.Watcher.ExitProcessor.Core':get_invalid_piggybacks_events(#{'__struct__':='Elixir.OMG.Watcher.ExitProcessor.Core', 'competitors':=#{<<_:256>>=>map()}, 'exits':=#{{_,_,_,_}=>map()}, 'in_flight_exits':=#{<<_:256>>=>map()}, 'sla_margin':=non_neg_integer()},#{{'utxo_position',non_neg_integer(),non_neg_integer(),non_neg_integer()}=>[map()]}) -> [any()]
Type specification 'Elixir.OMG.Watcher.ExitProcessor.Core':invalid_piggybacks_by_ife('Elixir.OMG.Watcher.ExitProcessor.KnownTx':known_txs_by_input_t(),piggyback_type_t(),['Elixir.OMG.Watcher.ExitProcessor.InFlightExitInfo':t()]) -> [{'Elixir.OMG.Watcher.ExitProcessor.InFlightExitInfo':t(),piggyback_type_t(),#{non_neg_integer()=>'Elixir.OMG.Watcher.ExitProcessor.DoubleSpend':t()}}] is a subtype of the success typing: 'Elixir.OMG.Watcher.ExitProcessor.Core':invalid_piggybacks_by_ife(#{{'utxo_position',non_neg_integer(),non_neg_integer(),non_neg_integer()}=>[map()]},_,[any()]) -> [any()]
Type specification 'Elixir.OMG.Watcher.ExitProcessor.Core':get_ife_txs_with_competitors('Elixir.OMG.Watcher.ExitProcessor.Core':t(),'Elixir.OMG.Watcher.ExitProcessor.KnownTx':known_txs_by_input_t()) -> [binary()] is a subtype of the success typing: 'Elixir.OMG.Watcher.ExitProcessor.Core':get_ife_txs_with_competitors(#{'__struct__':='Elixir.OMG.Watcher.ExitProcessor.Core', 'competitors':=#{<<_:256>>=>map()}, 'exits':=#{{_,_,_,_}=>map()}, 'in_flight_exits':=#{<<_:256>>=>map()}, 'sla_margin':=non_neg_integer()},#{{'utxo_position',non_neg_integer(),non_neg_integer(),non_neg_integer()}=>[map()]}) -> [any()]
Type specification 'Elixir.OMG.Watcher.ExitProcessor.DoubleSpend':find_competitor('Elixir.OMG.Watcher.ExitProcessor.KnownTx':known_txs_by_input_t(),'Elixir.OMG.State.Transaction':any_flavor_t()) -> 'nil' | t() is a subtype of the success typing: 'Elixir.OMG.Watcher.ExitProcessor.DoubleSpend':find_competitor(map(),#{'__struct__':='Elixir.OMG.State.Transaction' | 'Elixir.OMG.State.Transaction.Recovered' | 'Elixir.OMG.State.Transaction.Signed', 'inputs'=>[#{'blknum':=non_neg_integer(), 'oindex':=non_neg_integer(), 'txindex':=non_neg_integer()}], 'metadata'=>'nil' | binary(), 'outputs'=>[#{'amount':=non_neg_integer(), 'currency':=<<_:160>>, 'owner':=<<_:160>>}], 'raw_tx'=>#{'__struct__':='Elixir.OMG.State.Transaction', 'inputs':=[map()], 'metadata':='nil' | binary(), 'outputs':=[map()]}, 'signed_tx'=>#{'__struct__':='Elixir.OMG.State.Transaction.Signed', 'raw_tx':=#{'__struct__':='Elixir.OMG.State.Transaction', 'inputs':=[any()], 'metadata':='nil' | binary(), 'outputs':=[any()]}, 'signed_tx_bytes':='nil' | binary(), 'sigs':=[<<_:520>>]}, 'signed_tx_bytes'=>'nil' | binary(), 'sigs'=>[<<_:520>>], 'spenders'=>[<<_:160>>], 'tx_hash'=><<_:256>>}) -> 'nil' | #{'__struct__':='Elixir.OMG.Watcher.ExitProcessor.DoubleSpend', 'index':=non_neg_integer(), 'known_spent_index':=non_neg_integer(), 'known_tx':=#{'__struct__':='Elixir.OMG.Watcher.ExitProcessor.KnownTx', 'signed_tx':=#{'__struct__':='Elixir.OMG.State.Transaction.Signed', 'raw_tx':=map(), 'signed_tx_bytes':='nil' | binary(), 'sigs':=[any()]}, 'utxo_pos':='nil' | {'utxo_position',non_neg_integer(),non_neg_integer(),non_neg_integer()}}, 'utxo_pos':={'utxo_position',non_neg_integer(),non_neg_integer(),non_neg_integer()}}
Type specification 'Elixir.OMG.Watcher.ExitProcessor.Core':produce_invalid_piggyback_proof('Elixir.OMG.Watcher.ExitProcessor.InFlightExitInfo':t(),'Elixir.OMG.Watcher.ExitProcessor.KnownTx':known_txs_by_input_t(),piggyback_t()) -> {'ok',input_challenge_data() | output_challenge_data()} | {'error','no_double_spend_on_particular_piggyback'} is a subtype of the success typing: 'Elixir.OMG.Watcher.ExitProcessor.Core':produce_invalid_piggyback_proof(#{'__struct__':='Elixir.OMG.Watcher.ExitProcessor.InFlightExitInfo', 'contract_id':=<<_:192>>, 'contract_tx_pos':='nil' | {'utxo_position',non_neg_integer(),non_neg_integer(),non_neg_integer()}, 'eth_height':=pos_integer(), 'exit_map':=#{non_neg_integer()=>#{'is_finalized':=boolean(), 'is_piggybacked':=boolean()}}, 'is_active':=boolean(), 'is_canonical':=boolean(), 'oldest_competitor':='nil' | {'utxo_position',non_neg_integer(),non_neg_integer(),non_neg_integer()}, 'timestamp':=non_neg_integer(), 'tx':=#{'__struct__':='Elixir.OMG.State.Transaction.Signed', 'raw_tx':=#{'__struct__':='Elixir.OMG.State.Transaction', 'inputs':=[any()], 'metadata':='nil' | binary(), 'outputs':=[any()]}, 'signed_tx_bytes':='nil' | binary(), 'sigs':=[<<_:520>>]}, 'tx_seen_in_blocks_at':='nil' | {{'utxo_position',non_neg_integer(),non_neg_integer(),non_neg_integer()},binary()}},#{{'utxo_position',non_neg_integer(),non_neg_integer(),non_neg_integer()}=>[#{'__struct__':='Elixir.OMG.Watcher.ExitProcessor.KnownTx', 'signed_tx':=map(), 'utxo_pos':='nil' | {_,_,_,_}}]},{'input',_} | {'output',_}) -> {'error','no_double_spend_on_particular_piggyback'} | {'ok',#{'in_flight_input_index':=0 | 1 | 2 | 3 | 4 | 5 | 6 | 7, 'in_flight_txbytes':=binary(), 'spending_input_index':=0 | 1 | 2 | 3, 'spending_sig':=<<_:520>>, 'spending_txbytes':=binary(), 'in_flight_output_pos'=>pos_integer()}}
Type specification 'Elixir.OMG.Watcher.ExitProcessor.DoubleSpend':all_double_spends_by_index([{'Elixir.OMG.Utxo.Position':t(),non_neg_integer()}],map(),'Elixir.OMG.State.Transaction':any_flavor_t()) -> #{non_neg_integer()=>t()} is a subtype of the success typing: 'Elixir.OMG.Watcher.ExitProcessor.DoubleSpend':all_double_spends_by_index(_,map(),_) -> map()
Type specification 'Elixir.OMG.Watcher.ExitProcessor.Core':check_validity('Elixir.OMG.Watcher.ExitProcessor.Request':t(),t()) -> check_validity_result_t() is not equal to the success typing: 'Elixir.OMG.Watcher.ExitProcessor.Core':check_validity(#{'__struct__':='Elixir.OMG.Watcher.ExitProcessor.Request', 'blocks_result':=maybe_improper_list() | #{'__struct__':='Elixir.OMG.Block' | 'Elixir.OMG.Watcher.ExitProcessor.Core', _=>_}, 'eth_height_now':=pos_integer(), 'utxo_exists_result':=_, 'utxos_to_check':=_, _=>_},#{'__struct__':='Elixir.OMG.Watcher.ExitProcessor.Core', 'competitors':=#{<<_:256>>=>map()}, 'exits':=#{{_,_,_,_}=>map()}, 'in_flight_exits':=#{<<_:256>>=>map()}, 'sla_margin':=non_neg_integer()}) -> {'ok' | {'error','unchallenged_exit'},[any()]}
Type specification 'Elixir.OMG.EthereumHeight':get() -> {'ok',non_neg_integer()} | {'error','error_ethereum_height'} is a subtype of the success typing: 'Elixir.OMG.EthereumHeight':get() -> any()
Type specification 'Elixir.OMG.EthereumHeight':get_ethereum_height() -> non_neg_integer() | 'error_ethereum_height' is a subtype of the success typing: 'Elixir.OMG.EthereumHeight':get_ethereum_height() -> any()
#websockex
The call 'Elixir.OMG.Eth.SubscriptionWorker':start_link(_params@1::[{'listen_to',<<_:64>>} | {'ws_url',_},...]) will never return since it differs in the 1st argument from the success typing arguments: ([{'async' | 'cacerts' | 'debug' | 'extra_headers' | 'handle_initial_conn_failure' | 'insecure' | 'name' | 'socket_connect_timeout' | 'socket_recv_timeout',atom() | [any()] | non_neg_integer() | {_,_} | {_,_,_}}])
lib/websockex.ex:19: Function handle_cast/2 only terminates with explicit exception
lib/websockex.ex:297: Expression produces a value of type 'ok' | {'error',_}, but this value is unmatched
#Phoenix
The pattern 'error' can never match the type {#{'conn':='nil', 'log':='debug', 'path_params':=map(), 'pipe_through':=[any(),...], 'plug':='Elixir.OMG.ChildChainRPC.Web.Controller.Block' | 'Elixir.OMG.ChildChainRPC.Web.Controller.Fallback' | 'Elixir.OMG.ChildChainRPC.Web.Controller.Transaction', 'plug_opts':='Elixir.Route.NotFound' | 'get_block' | 'submit', 'route':=<<_:48,_:_*8>>},fun((_,map()) -> any()),fun((_) -> map()),{'Elixir.OMG.ChildChainRPC.Web.Controller.Block','get_block'} | {'Elixir.OMG.ChildChainRPC.Web.Controller.Fallback','Elixir.Route.NotFound'} | {'Elixir.OMG.ChildChainRPC.Web.Controller.Transaction','submit'}}
The pattern 'error' can never match the type {#{'conn':='nil', 'log':='debug', 'path_params':=map(), 'pipe_through':=[any(),...], 'plug':='Elixir.OMG.WatcherRPC.Web.Controller.Account' | 'Elixir.OMG.WatcherRPC.Web.Controller.Challenge' | 'Elixir.OMG.WatcherRPC.Web.Controller.Fallback' | 'Elixir.OMG.WatcherRPC.Web.Controller.InFlightExit' | 'Elixir.OMG.WatcherRPC.Web.Controller.Status' | 'Elixir.OMG.WatcherRPC.Web.Controller.Transaction' | 'Elixir.OMG.WatcherRPC.Web.Controller.Utxo', 'plug_opts':=atom(), 'route':=<<_:48,_:_*8>>},fun((_,map()) -> any()),fun((_) -> map()),{'Elixir.OMG.WatcherRPC.Web.Controller.Account' | 'Elixir.OMG.WatcherRPC.Web.Controller.Challenge' | 'Elixir.OMG.WatcherRPC.Web.Controller.Fallback' | 'Elixir.OMG.WatcherRPC.Web.Controller.InFlightExit' | 'Elixir.OMG.WatcherRPC.Web.Controller.Status' | 'Elixir.OMG.WatcherRPC.Web.Controller.Transaction' | 'Elixir.OMG.WatcherRPC.Web.Controller.Utxo',atom()}}
apps/omg_child_chain/lib/child_chain.ex:35: Type specification 'Elixir.OMG.ChildChain':submit(transaction::binary()) -> {'ok',#{'txhash':='Elixir.OMG.State.Transaction':tx_hash(),'blknum':=pos_integer(),'txindex':=non_neg_integer()}} | {'error',submit_error()} is a subtype of the success typing: 'Elixir.OMG.ChildChain':submit(binary()) -> {'error',_} | {'ok',#{'blknum':=_, _=>_}}
apps/omg_child_chain/lib/child_chain.ex:49: Type specification 'Elixir.OMG.ChildChain':get_block(hash::binary()) -> {'ok',#{'hash':=binary(),'transactions':=[any()],'blknum':=integer()}} | {'error','not_found' | 'internal_error'} is a subtype of the success typing: 'Elixir.OMG.ChildChain':get_block(binary()) -> {'error',_} | {'ok',#{'blknum':=_, _=>_}}
apps/omg_eth/lib/omg_eth/root_chain.ex:144: Type specification 'Elixir.OMG.Eth.RootChain':get_piggybacks(non_neg_integer(),non_neg_integer(),optional_addr_t()) -> {'ok',[in_flight_exit_piggybacked_event()]} | {'error','failed_to_get_ethereum_events'} is a subtype of the success typing: 'Elixir.OMG.Eth.RootChain':get_piggybacks(_,_,_) -> {'error','failed_to_get_ethereum_events'} | {'ok',[any()]}
apps/omg_watcher/lib/omg_watcher/api/status.ex:51: Type specification 'Elixir.OMG.Watcher.API.Status':get_status() -> {'ok',t()} is a subtype of the success typing: 'Elixir.OMG.Watcher.API.Status':get_status() -> {'ok','Elixir.OMG.Watcher.API.Status':t() | #{'byzantine_events':=[any()], 'contract_addr':=binary(), 'eth_syncing':=boolean(), 'in_flight_exits':=#{binary()=>map()}, 'last_mined_child_block_number':=number(), 'last_mined_child_block_timestamp':=_, 'last_seen_eth_block_number':=non_neg_integer(), 'last_seen_eth_block_timestamp':=_, 'last_validated_child_block_number':=integer(), 'last_validated_child_block_timestamp':=_, 'services_synced_heights':=#{atom()=>non_neg_integer()}}}
apps/omg_watcher/lib/omg_watcher/api/transaction.ex:34: Type specification 'Elixir.OMG.Watcher.API.Transaction':get(binary()) -> {'ok',#{'__struct__':='Elixir.OMG.Watcher.DB.Transaction','__meta__':=term(),'blknum':=term(),'block':=term(),'inputs':=term(),'metadata':=term(),'outputs':=term(),'sent_at':=term(),'txbytes':=term(),'txhash':=term(),'txindex':=term()}} | {'error','transaction_not_found'} is a subtype of the success typing: 'Elixir.OMG.Watcher.API.Transaction':get(_) -> {'error','transaction_not_found'} | {'ok',_}
apps/omg_watcher/lib/omg_watcher/api/transaction.ex:79: Type specification 'Elixir.OMG.Watcher.API.Transaction':create('Elixir.OMG.Watcher.UtxoSelection':order_t()) -> 'Elixir.OMG.Watcher.UtxoSelection':advice_t() is a subtype of the success typing: 'Elixir.OMG.Watcher.API.Transaction':create(#{'fee':=#{'amount':=non_neg_integer(), 'currency':=<<_:160>>}, 'metadata':='nil' | binary(), 'owner':=<<_:160>>, 'payments':=[#{'amount':=pos_integer(), 'currency':=<<_:160>>, 'owner':='nil' | <<_:160>>},...]}) -> {'error','empty_transaction' | 'too_many_outputs'} | {'ok',#{'result':='complete' | 'intermediate', 'transactions':=[map(),...]}} | {'error','insufficient_funds',[map()]}
apps/omg_watcher/lib/omg_watcher/db/txoutput.ex:63: Type specification 'Elixir.OMG.Watcher.DB.TxOutput':compose_utxo_exit('Elixir.OMG.Utxo.Position':t()) -> {'ok',exit_t()} | {'error','utxo_not_found'} is a subtype of the success typing: 'Elixir.OMG.Watcher.DB.TxOutput':compose_utxo_exit({'utxo_position',non_neg_integer(),non_neg_integer(),non_neg_integer()}) -> {'error','no_deposit_for_given_blknum' | 'utxo_not_found'} | {'ok',#{'proof':=binary(), 'txbytes':=binary(), 'utxo_pos':=non_neg_integer(), 'sigs'=>binary()}}
apps/omg_watcher/lib/omg_watcher/db/txoutput.ex:139: Type specification 'Elixir.OMG.Watcher.DB.TxOutput':get_balance('Elixir.OMG.Crypto':address_t()) -> [balance()] is a subtype of the success typing: 'Elixir.OMG.Watcher.DB.TxOutput':get_balance(_) -> [any()]
apps/omg_watcher/lib/omg_watcher/db/txoutput.ex:158: Type specification 'Elixir.OMG.Watcher.DB.TxOutput':spend_utxos([map()]) -> 'ok' is a subtype of the success typing: 'Elixir.OMG.Watcher.DB.TxOutput':spend_utxos(_) -> 'ok'
apps/omg_watcher/lib/omg_watcher/db/txoutput.ex:170: Type specification 'Elixir.OMG.Watcher.DB.TxOutput':create_outputs(pos_integer(),integer(),binary(),'Elixir.OMG.State.Transaction':any_flavor_t()) -> [map()] is a subtype of the success typing: 'Elixir.OMG.Watcher.DB.TxOutput':create_outputs(_,_,_,#{'__struct__':='Elixir.OMG.State.Transaction' | 'Elixir.OMG.State.Transaction.Recovered' | 'Elixir.OMG.State.Transaction.Signed', 'inputs'=>[map()], 'metadata'=>'nil' | binary(), 'outputs'=>[map()], 'raw_tx'=>#{'__struct__':='Elixir.OMG.State.Transaction', 'inputs':=[any()], 'metadata':='nil' | binary(), 'outputs':=[any()]}, 'signed_tx'=>#{'__struct__':='Elixir.OMG.State.Transaction.Signed', 'raw_tx':=map(), 'signed_tx_bytes':='nil' | binary(), 'sigs':=[any()]}, 'signed_tx_bytes'=>'nil' | binary(), 'sigs'=>[<<_:520>>], 'spenders'=>[<<_:160>>], 'tx_hash'=><<_:256>>}) -> [any()]
apps/omg_watcher/lib/omg_watcher/db/txoutput.ex:205: Type specification 'Elixir.OMG.Watcher.DB.TxOutput':create_inputs('Elixir.OMG.State.Transaction':any_flavor_t(),binary()) -> [tuple()] is a subtype of the success typing: 'Elixir.OMG.Watcher.DB.TxOutput':create_inputs(#{'__struct__':='Elixir.OMG.State.Transaction' | 'Elixir.OMG.State.Transaction.Recovered' | 'Elixir.OMG.State.Transaction.Signed', 'inputs'=>[map()], 'metadata'=>'nil' | binary(), 'outputs'=>[map()], 'raw_tx'=>#{'__struct__':='Elixir.OMG.State.Transaction', 'inputs':=[any()], 'metadata':='nil' | binary(), 'outputs':=[any()]}, 'signed_tx'=>#{'__struct__':='Elixir.OMG.State.Transaction.Signed', 'raw_tx':=map(), 'signed_tx_bytes':='nil' | binary(), 'sigs':=[any()]}, 'signed_tx_bytes'=>'nil' | binary(), 'sigs'=>[<<_:520>>], 'spenders'=>[<<_:160>>], 'tx_hash'=><<_:256>>},_) -> [any()]
apps/omg_watcher/lib/omg_watcher/db/txoutput.ex:216: Type specification 'Elixir.OMG.Watcher.DB.TxOutput':get_sorted_grouped_utxos('Elixir.OMG.Crypto':address_t()) -> #{'Elixir.OMG.Crypto':address_t()=>[#{'__struct__':='Elixir.OMG.Watcher.DB.TxOutput','__meta__':=term(),'amount':=term(),'blknum':=term(),'creating_deposit':=term(),'creating_transaction':=term(),'creating_txhash':=term(),'currency':=term(),'deposit':=term(),'exit':=term(),'oindex':=term(),'owner':=term(),'proof':=term(),'spending_exit':=term(),'spending_transaction':=term(),'spending_tx_oindex':=term(),'spending_txhash':=term(),'txindex':=term()}]} is a subtype of the success typing: 'Elixir.OMG.Watcher.DB.TxOutput':get_sorted_grouped_utxos(_) -> map()
apps/omg/lib/omg/crypto.ex:35: Type specification 'Elixir.OMG.Crypto':hash(binary()) -> hash_t() is a subtype of the success typing: 'Elixir.OMG.Crypto':hash(binary() | maybe_improper_list(binary() | maybe_improper_list(any(),binary() | []) | byte(),binary() | [])) -> binary()
apps/omg/lib/omg/state/transaction.ex:266: Type specification 'Elixir.OMG.State.Transaction':raw_txhash(any_flavor_t()) -> tx_hash() is a subtype of the success typing: 'Elixir.OMG.State.Transaction':raw_txhash(#{'__struct__':='Elixir.OMG.State.Transaction' | 'Elixir.OMG.State.Transaction.Recovered' | 'Elixir.OMG.State.Transaction.Signed', _=>_}) -> any()
apps/omg/lib/omg/typed_data_hash.ex:41: Type specification 'Elixir.OMG.TypedDataHash':hash_struct('Elixir.OMG.State.Transaction':t(),'Elixir.OMG.Crypto':domain_separator_t()) -> 'Elixir.OMG.Crypto':hash_t() is a subtype of the success typing: 'Elixir.OMG.TypedDataHash':hash_struct(#{'__struct__':='Elixir.OMG.State.Transaction', 'inputs':=[#{'blknum':=non_neg_integer(), 'oindex':=non_neg_integer(), 'txindex':=non_neg_integer()}], 'metadata':='nil' | binary(), 'outputs':=[#{'amount':=non_neg_integer(), 'currency':=<<_:160>>, 'owner':=<<_:160>>}]},'false' | 'nil' | binary()) -> <<_:256>>
apps/omg/lib/omg/typed_data_hash/tools.ex:45: Type specification 'Elixir.OMG.TypedDataHash.Tools':domain_separator(binary(),binary(),'Elixir.OMG.Crypto':address_t(),'Elixir.OMG.Crypto':hash_t()) -> 'Elixir.OMG.Crypto':hash_t() is a subtype of the success typing: 'Elixir.OMG.TypedDataHash.Tools':domain_separator(binary(),binary(),_,_) -> <<_:256>>
apps/omg/lib/omg/typed_data_hash/tools.ex:59: Type specification 'Elixir.OMG.TypedDataHash.Tools':hash_transaction(['Elixir.OMG.Utxo.Position':t()],['Elixir.OMG.State.Transaction':output()],'Elixir.OMG.State.Transaction':metadata(),'Elixir.OMG.Crypto':hash_t(),'Elixir.OMG.Crypto':hash_t()) -> 'Elixir.OMG.Crypto':hash_t() is a subtype of the success typing: 'Elixir.OMG.TypedDataHash.Tools':hash_transaction(_,_,_,_,_) -> <<_:256>>
apps/omg/lib/omg/typed_data_hash/tools.ex:92: Type specification 'Elixir.OMG.TypedDataHash.Tools':hash_input('Elixir.OMG.Utxo.Position':t()) -> 'Elixir.OMG.Crypto':hash_t() is a subtype of the success typing: 'Elixir.OMG.TypedDataHash.Tools':hash_input({'utxo_position',_,_,_}) -> <<_:256>>
apps/omg/lib/omg/typed_data_hash/tools.ex:104: Type specification 'Elixir.OMG.TypedDataHash.Tools':hash_output('Elixir.OMG.State.Transaction':output()) -> 'Elixir.OMG.Crypto':hash_t() is a subtype of the success typing: 'Elixir.OMG.TypedDataHash.Tools':hash_output(#{'amount':=_, 'currency':=_, 'owner':=_, _=>_}) -> <<_:256>>
apps/omg_watcher/lib/omg_watcher/db/eth_event.ex:106: Type specification 'Elixir.OMG.Watcher.DB.EthEvent':generate_unique_key('Elixir.OMG.Utxo.Position':t(),'deposit' | 'exit') -> 'Elixir.OMG.Crypto':hash_t() is a subtype of the success typing: 'Elixir.OMG.Watcher.DB.EthEvent':generate_unique_key({'utxo_position',non_neg_integer(),non_neg_integer(),non_neg_integer()},_) -> <<_:256>>
